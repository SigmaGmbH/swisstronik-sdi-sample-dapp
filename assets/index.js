function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b, e2) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b, e2) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b, e2) {
  var d2, c = {}, k2 = null, h2 = null;
  if (null != b)
    for (d2 in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b)
      J.call(b, d2) && !L$1.hasOwnProperty(d2) && (c[d2] = b[d2]);
  var g = arguments.length - 2;
  if (1 === g)
    c.children = e2;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
      f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps)
    for (d2 in g = a.defaultProps, g)
      void 0 === c[d2] && (c[d2] = g[d2]);
  return { $$typeof: l$1, type: a, key: k2, ref: h2, props: c, _owner: K$2.current };
}
function N$1(a, b) {
  return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$1;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R$1(a, b, e2, d2, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$1:
          case n$1:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c = c(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c, b, e2, "", function(a2) {
      return a2;
    })) : null != c && (O$1(c) && (c = N$1(c, e2 + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a))
    for (var g = 0; g < a.length; g++) {
      k2 = a[g];
      var f2 = d2 + Q$1(k2, g);
      h2 += R$1(k2, b, e2, f2, c);
    }
  else if (f2 = A$1(a), "function" === typeof f2)
    for (a = f2.call(a), g = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g++), h2 += R$1(k2, b, e2, f2, c);
  else if ("object" === k2)
    throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b, e2) {
  if (null == a)
    return a;
  var d2 = [], c = 0;
  R$1(a, d2, "", "", function(a2) {
    return b.call(e2, a2, c++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$1, forEach: function(a, b, e2) {
  S$1(a, function() {
    b.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b = 0;
  S$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a, b, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h2 = K$2.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f2 in b)
      J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g[m2] = arguments[m2 + 2];
    d2.children = g;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b = M$1.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$1, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x$1, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b) {
  return U$1.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U$1.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e2) {
  return U$1.current.useImperativeHandle(a, b, e2);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U$1.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U$1.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U$1.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e2) {
  return U$1.current.useReducer(a, b, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e2) {
  return U$1.current.useSyncExternalStore(a, b, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d2 = {}, e2 = null, h2 = null;
  void 0 !== g && (e2 = "" + g);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b in a)
    m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d2[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d2[b] && (d2[b] = a[b]);
  return { $$typeof: k, type: c, key: e2, ref: h2, props: d2, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; 0 < c; ) {
        var d2 = c - 1 >>> 1, e2 = a[d2];
        if (0 < g(e2, b))
          a[d2] = b, a[c] = e2, c = d2;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b = a[0], c = a.pop();
    if (c !== b) {
      a[0] = c;
      a:
        for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x = a[n2];
          if (0 > g(C2, c))
            n2 < e2 && 0 > g(x, C2) ? (a[d2] = x, a[n2] = c, d2 = n2) : (a[d2] = C2, a[m2] = c, d2 = m2);
          else if (n2 < e2 && 0 > g(x, c))
            a[d2] = x, a[n2] = c, d2 = n2;
          else
            break a;
        }
    }
    return b;
  }
  function g(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b = h2(t2); null !== b; ) {
      if (null === b.callback)
        k2(t2);
      else if (b.startTime <= a)
        k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
      else
        break;
      b = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b = h2(t2);
        null !== b && K2(H2, b.startTime - a);
      }
  }
  function J2(a, b) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z = true;
    var c = y2;
    try {
      G2(b);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b = true;
      try {
        b = O2(true, a);
      } finally {
        b ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = y2;
    }
    var c = y2;
    y2 = b;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d2 = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d2 + c : d2) : c = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e2, sortIndex: -1 };
    c > d2 ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b = y2;
    return function() {
      var c = y2;
      y2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++)
    da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b, c, d2) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b, c, d2) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d2))
    return true;
  if (d2)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function v(a, b, c, d2, e2, f2, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z$1[b] = new v(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ra,
    sa
  );
  z$1[b] = new v(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ra, sa);
  z$1[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ra, sa);
  z$1[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b, c, d2) {
  var e2 = z$1.hasOwnProperty(b) ? z$1[b] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1])
    qa(b, c, e2, d2) && (c = null), d2 || null === e2 ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e2.mustUseProperty ? a[e2.propertyName] = null === c ? 3 === e2.type ? false : "" : c : (b = e2.attributeName, d2 = e2.attributeNamespace, null === c ? a.removeAttribute(b) : (e2 = e2.type, c = 3 === e2 || 4 === e2 && true === c ? "" : "" + c, d2 ? a.setAttributeNS(d2, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b) {
  if (!a || Na)
    return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g = e2.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e2[g] !== f2[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e2[g] !== f2[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e2[g] !== f2[h2]) {
                var k2 = "\n" + e2[g].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b)
        return b.displayName || b.name || null;
      if ("string" === typeof b)
        return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d2 = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e2 = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d2 = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d2, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, false);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value), d2 = b.type;
  if (null != c)
    if ("number" === d2) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d2 = b.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b.value && null !== b.value))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d2) {
  a = a.options;
  if (b) {
    b = {};
    for (var e2 = 0; e2 < c.length; e2++)
      b["$" + c[e2]] = true;
    for (c = 0; c < a.length; c++)
      e2 = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e2 && (a[c].selected = e2), e2 && d2 && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b || a[e2].disabled || (b = a[e2]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML)
    throw Error(p(91));
  return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b)
        throw Error(p(92));
      if (eb(c)) {
        if (1 < c.length)
          throw Error(p(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d2 = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d2, e2);
    });
  } : a;
}(function(a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d2 = 0 === c.indexOf("--"), e2 = rb(c, b[c], d2);
      "float" === c && (c = "cssFloat");
      d2 ? a.setProperty(c, e2) : a[c] = e2;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
      throw Error(p(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children)
        throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
        throw Error(p(61));
    }
    if (null != b.style && "object" !== typeof b.style)
      throw Error(p(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {
}
var Ib = false;
function Jb(a, b, c) {
  if (Ib)
    return a(b, c);
  Ib = true;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d2 = Db(c);
  if (null === d2)
    return null;
  c = d2[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(p(231, b, typeof c));
  return c;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b, c, d2, e2, f2, g, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b, c, d2, e2, f2, g, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d2, e2, f2, g, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b)
      return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b)
      throw Error(p(188));
    return b !== a ? null : a;
  }
  for (var c = a, d2 = b; ; ) {
    var e2 = c.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c)
          return Xb(e2), a;
        if (f2 === d2)
          return Xb(e2), b;
        f2 = f2.sibling;
      }
      throw Error(p(188));
    }
    if (c.return !== d2.return)
      c = e2, d2 = f2;
    else {
      for (var g = false, h2 = e2.child; h2; ) {
        if (h2 === c) {
          g = true;
          c = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g = true;
          d2 = e2;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g = true;
            c = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g = true;
            d2 = f2;
            c = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p(189));
      }
    }
    if (c.alternate !== d2)
      throw Error(p(190));
  }
  if (3 !== c.tag)
    throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b = $b(a);
    if (null !== b)
      return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec$1 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c)
    return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
  if (0 !== g) {
    var h2 = g & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g, 0 !== f2 && (d2 = tc(f2)));
  } else
    g = c & ~e2, 0 !== g ? d2 = tc(g) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b && b !== d2 && 0 === (b & e2) && (e2 = d2 & -d2, f2 = b & -b, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b;
  0 !== (d2 & 4) && (d2 |= c & 16);
  b = a.entangledLanes;
  if (0 !== b)
    for (a = a.entanglements, b &= d2; 0 < b; )
      c = 31 - oc(b), e2 = 1 << c, d2 |= a[c], b &= ~e2;
  return d2;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h2 = 1 << g, k2 = e2[g];
    if (-1 === k2) {
      if (0 === (h2 & c) || 0 !== (h2 & d2))
        e2[g] = vc(h2, b);
    } else
      k2 <= b && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e2 = 31 - oc(c), f2 = 1 << e2;
    b[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c &= ~f2;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c; ) {
    var d2 = 31 - oc(c), e2 = 1 << d2;
    e2 & b | a[d2] & b && (a[d2] |= b);
    c &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b, domEventName: c, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d2;
  b = a.targetContainers;
  null !== e2 && -1 === b.indexOf(e2) && b.push(e2);
  return a;
}
function Uc(a, b, c, d2, e2) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = Wb(c), null !== b) {
          a.blockedOn = b;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d2 = new c.constructor(c.type, c);
      wb = d2;
      c.target.dispatchEvent(d2);
      wb = null;
    } else
      return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b2) {
    return ad(b2, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d2 = Kc[c];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++)
    d2 = Qc[c], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); )
    Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b, c, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b, c, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b, c, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b, c, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b, c, d2) {
  if (dd) {
    var e2 = Yc(a, b, c, d2);
    if (null === e2)
      hd(a, b, d2, id$1, c), Sc(a, d2);
    else if (Uc(e2, a, b, c, d2))
      d2.stopPropagation();
    else if (Sc(a, d2), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b, c, d2);
        null === f2 && hd(a, b, d2, id$1, c);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a, b, d2, null, c);
  }
}
var id$1 = null;
function Yc(a, b, c, d2) {
  id$1 = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a)
    if (b = Vb(a), null === b)
      a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated)
        return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else
      b !== a && (a = null);
  id$1 = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c && b[a] === e2[a]; a++)
    ;
  var g = c - a;
  for (d2 = 1; d2 <= g && b[c - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d2, e2, f2, g) {
    this._reactName = b2;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b)
      return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d2) {
  Eb(d2);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d2), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if ("change" === a)
    return b;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b) {
  if ("click" === a)
    return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a)
    return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
    return false;
  var c = Object.keys(a), d2 = Object.keys(b);
  if (c.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c.length; d2++) {
    var e2 = c[d2];
    if (!ja.call(b, e2) || !He(a[e2], b[e2]))
      return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d2; c; ) {
    if (3 === c.nodeType) {
      d2 = a + c.textContent.length;
      if (a <= b && d2 >= b)
        return { node: c, offset: b - a };
      a = d2;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d2) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(), c = a.focusedElem, d2 = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d2 && Ne(c)) {
      if (b = d2.start, a = d2.end, void 0 === a && (a = b), "selectionStart" in c)
        c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c, f2);
        var g = Ke(
          c,
          d2
        );
        e2 && g && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
      }
    }
    b = [];
    for (a = c; a = a.parentNode; )
      1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++)
      a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d2 = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d2 }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b = We[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Ye)
      return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d2, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d2 = a[c], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b)
        for (var g = d2.length - 1; 0 <= g; g--) {
          var h2 = d2[g], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g = 0; g < d2.length; g++) {
          h2 = d2[g];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c.has(d2) || (pf(b, a, 2, false), c.add(d2));
}
function qf(a, b, c) {
  var d2 = 0;
  b && (d2 |= 4);
  pf(c, a, d2, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b2) {
      "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
  }
}
function pf(a, b, c, d2) {
  switch (jd(b)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c = e2.bind(null, b, c, a);
  e2 = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b, c, { capture: true, passive: e2 }) : a.addEventListener(b, c, true) : void 0 !== e2 ? a.addEventListener(b, c, { passive: e2 }) : a.addEventListener(b, c, false);
}
function hd(a, b, c, d2, e2) {
  var f2 = d2;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g)
            for (g = d2.return; null !== g; ) {
              var k2 = g.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c), g2 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x && (F2 = Kb(w2, x), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c, e3), g2.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x, w2 + "enter", n2, c, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x = vf(x), u2--;
                for (; w2--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate)
                    break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g2, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g2, na, c, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e3), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c, e3), g2.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g2, b);
  });
}
function tf(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d2, e2) {
  for (var f2 = b._reactName, g = []; null !== c && c !== d2; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h2))) : e2 || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h2))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c)
    throw Error(p(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b) {
  var c = b, d2 = 0;
  do {
    var e2 = c.nextSibling;
    a.removeChild(c);
    if (e2 && 8 === e2.nodeType)
      if (c = e2.data, "/$" === c) {
        if (0 === d2) {
          a.removeChild(e2);
          bd(b);
          return;
        }
        d2--;
      } else
        "$" !== c && "$?" !== c && "$!" !== c || d2++;
    c = e2;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b)
      break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b)
        break;
      if ("/$" === b)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b)
          return a;
        b--;
      } else
        "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child)
        for (a = Mf(a); null !== a; ) {
          if (c = a[Of])
            return c;
          a = Mf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c)
    e2[f2] = b[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf)
    throw Error(p(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d2 = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b))
      throw Error(p(108, Ra(a) || "Unknown", e2));
  return A({}, c, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b, c) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(p(169));
  c ? (a = bg(a, b, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d2 = c[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c += 1;
  var f2 = 32 - oc(b) + e2;
  if (30 < f2) {
    var g = e2 - e2 % 5;
    f2 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    e2 -= g;
    rg = 1 << 32 - oc(b) + e2 | c << e2 | d2;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a))
          throw Error(p(418));
        b = Lf(c.nextSibling);
        var d2 = xg;
        b && Cg(a, b) ? Ag(d2, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a))
      throw Hg(), Error(p(418));
    for (; b; )
      Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b = Mg.current;
  E(Mg);
  a._currentValue = b;
}
function Sg(a, b, c) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d2 && (d2.childLanes |= b)) : null !== d2 && (d2.childLanes & b) !== b && (d2.childLanes |= b);
    if (a === c)
      break;
    a = a.return;
  }
}
function Tg(a, b) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b = a._currentValue;
  if (Pg !== a)
    if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p(308));
      Og = a;
      Ng.dependencies = { lanes: 0, firstContext: a };
    } else
      Og = Og.next = a;
  return b;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b, c, d2) {
  var e2 = b.interleaved;
  null === e2 ? (c.next = c, Xg(b)) : (c.next = e2.next, e2.next = c);
  b.interleaved = c;
  return Zg(a, d2);
}
function Zg(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b, c) {
  var d2 = a.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b.next = b : (b.next = e2.next, e2.next = b);
    d2.pending = b;
    return Zg(a, c);
  }
  e2 = d2.interleaved;
  null === e2 ? (b.next = b, Xg(d2)) : (b.next = e2.next, e2.next = b);
  d2.interleaved = b;
  return Zg(a, c);
}
function eh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d2 = b.lanes;
    d2 &= a.pendingLanes;
    c |= d2;
    b.lanes = c;
    Cc(a, c);
  }
}
function fh(a, b) {
  var c = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c === d2)) {
    var e2 = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e2 = f2 = g : f2 = f2.next = g;
        c = c.next;
      } while (null !== c);
      null === f2 ? e2 = f2 = b : f2 = f2.next = b;
    } else
      e2 = f2 = b;
    c = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function gh(a, b, c, d2) {
  var e2 = a.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b = e2.shared.interleaved;
    if (null !== b) {
      e2 = b;
      do
        g |= e2.lane, e2 = e2.next;
      while (e2 !== b);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g;
    a.lanes = g;
    a.memoizedState = q2;
  }
}
function ih(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a)
    for (b = 0; b < a.length; b++) {
      var d2 = a[b], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c;
        if ("function" !== typeof e2)
          throw Error(p(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a, b, c, d2) {
  b = a.memoizedState;
  c = c(d2, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = dh(a, f2, e2);
  null !== b && (mh(b, a, e2, d2), eh(b, a, e2));
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = dh(a, f2, e2);
  null !== b && (mh(b, a, e2, d2), eh(b, a, e2));
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = L(), d2 = lh(a), e2 = ch(c, d2);
  e2.tag = 2;
  void 0 !== b && null !== b && (e2.callback = b);
  b = dh(a, e2, d2);
  null !== b && (mh(b, a, d2, c), eh(b, a, d2));
} };
function oh(a, b, c, d2, e2, f2, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d2) || !Ie(e2, f2) : true;
}
function ph(a, b, c) {
  var d2 = false, e2 = Vf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b) ? Xf : H.current, d2 = b.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = nh;
  a.stateNode = b;
  b._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function qh(a, b, c, d2) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d2);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d2);
  b.state !== a && nh.enqueueReplaceState(b, b.state, null);
}
function rh$1(a, b, c, d2) {
  var e2 = a.stateNode;
  e2.props = c;
  e2.state = a.memoizedState;
  e2.refs = jh;
  ah(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b, f2, c), e2.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function sh$1(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(p(309));
        var d2 = c.stateNode;
      }
      if (!d2)
        throw Error(p(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2)
        return b.ref;
      b = function(a2) {
        var b2 = e2.refs;
        b2 === jh && (b2 = e2.refs = {});
        null === a2 ? delete b2[f2] : b2[f2] = a2;
      };
      b._stringRef = f2;
      return b;
    }
    if ("string" !== typeof a)
      throw Error(p(284));
    if (!c._owner)
      throw Error(p(290, a));
  }
  return a;
}
function th(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function uh(a) {
  var b = a._init;
  return b(a._payload);
}
function vh(a) {
  function b(b2, c2) {
    if (a) {
      var d3 = b2.deletions;
      null === d3 ? (b2.deletions = [c2], b2.flags |= 16) : d3.push(c2);
    }
  }
  function c(c2, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b(c2, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
      null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e2(a2, b2) {
    a2 = wh(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d3) {
    b2.index = d3;
    if (!a)
      return b2.flags |= 1048576, c2;
    d3 = b2.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c2 ? (b2.flags |= 2, c2) : d3;
    b2.flags |= 2;
    return c2;
  }
  function g(b2) {
    a && null === b2.alternate && (b2.flags |= 2);
    return b2;
  }
  function h2(a2, b2, c2, d3) {
    if (null === b2 || 6 !== b2.tag)
      return b2 = xh(c2, a2.mode, d3), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k2(a2, b2, c2, d3) {
    var f3 = c2.type;
    if (f3 === ya)
      return m2(a2, b2, c2.props.children, d3, c2.key);
    if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b2.type))
      return d3 = e2(b2, c2.props), d3.ref = sh$1(a2, b2, c2), d3.return = a2, d3;
    d3 = yh(c2.type, c2.key, c2.props, null, a2.mode, d3);
    d3.ref = sh$1(a2, b2, c2);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b2, c2, d3) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = zh(c2, a2.mode, d3), b2.return = a2, b2;
    b2 = e2(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function m2(a2, b2, c2, d3, f3) {
    if (null === b2 || 7 !== b2.tag)
      return b2 = Ah(c2, a2.mode, d3, f3), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function q2(a2, b2, c2) {
    if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2)
      return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case va:
          return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh$1(a2, null, b2), c2.return = a2, c2;
        case wa:
          return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
        case Ha:
          var d3 = b2._init;
          return q2(a2, d3(b2._payload), c2);
      }
      if (eb(b2) || Ka(b2))
        return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
      th(a2, b2);
    }
    return null;
  }
  function r2(a2, b2, c2, d3) {
    var e3 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2)
      return null !== e3 ? null : h2(a2, b2, "" + c2, d3);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e3 ? k2(a2, b2, c2, d3) : null;
        case wa:
          return c2.key === e3 ? l2(a2, b2, c2, d3) : null;
        case Ha:
          return e3 = c2._init, r2(
            a2,
            b2,
            e3(c2._payload),
            d3
          );
      }
      if (eb(c2) || Ka(c2))
        return null !== e3 ? null : m2(a2, b2, c2, d3, null);
      th(a2, c2);
    }
    return null;
  }
  function y2(a2, b2, c2, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a2 = a2.get(c2) || null, h2(b2, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, k2(b2, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, l2(b2, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b2, c2, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a2 = a2.get(c2) || null, m2(b2, a2, d3, e3, null);
      th(b2, d3);
    }
    return null;
  }
  function n2(e3, g2, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x = u2, u2 = null) : x = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x);
        break;
      }
      a && u2 && null === n3.alternate && b(e3, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x;
    }
    if (w2 === h3.length)
      return c(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x = y2(u2, e3, w2, h3[w2], k3), null !== x && (a && null !== x.alternate && u2.delete(null === x.key ? w2 : x.key), g2 = f2(x, g2, w2), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
    a && u2.forEach(function(a2) {
      return b(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g2, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x = m3, m3 = null) : x = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x);
        break;
      }
      a && m3 && null === t3.alternate && b(e3, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x;
    }
    if (n3.done)
      return c(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh$1(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c(a2, l3);
                break;
              } else
                b(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh$1(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c(a2, d3);
                  break;
                }
              else
                b(a2, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d3, f3, h3);
      if (Ka(f3))
        return t2(a2, d3, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g(a2)) : c(a2, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh)
    throw Error(p(174));
  return a;
}
function Ih(a, b) {
  G(Gh, b);
  G(Fh, a);
  G(Eh, Dh);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(Eh);
  G(Eh, b);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh$1(a) {
  Hh(Gh.current);
  var b = Hh(Eh.current);
  var c = lb(b, a.type);
  b !== c && (G(Fh, a), G(Eh, c));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128))
        return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++)
    Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p(321));
}
function Wh(a, b) {
  if (null === b)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Xh(a, b, c, d2, e2, f2) {
  Rh = f2;
  N = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p(301));
      f2 += 1;
      P = O = null;
      b.updateQueue = null;
      Ph.current = $h;
      a = c(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b)
    throw Error(p(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = O.next;
  var b = null === P ? N.memoizedState : P.next;
  if (null !== b)
    P = b, O = a;
  else {
    if (null === a)
      throw Error(p(310));
    O = a;
    a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function fi(a) {
  var b = di(), c = b.queue;
  if (null === c)
    throw Error(p(311));
  c.lastRenderedReducer = a;
  var d2 = O, e2 = d2.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g = e2.next;
      e2.next = f2.next;
      f2.next = g;
    }
    d2.baseQueue = e2 = f2;
    c.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d2 : k2.next = h2;
    He(d2, b.memoizedState) || (Ug = true);
    b.memoizedState = d2;
    b.baseState = g;
    b.baseQueue = k2;
    c.lastRenderedState = d2;
  }
  a = c.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function gi(a) {
  var b = di(), c = b.queue;
  if (null === c)
    throw Error(p(311));
  c.lastRenderedReducer = a;
  var d2 = c.dispatch, e2 = c.pending, f2 = b.memoizedState;
  if (null !== e2) {
    c.pending = null;
    var g = e2 = e2.next;
    do
      f2 = a(f2, g.action), g = g.next;
    while (g !== e2);
    He(f2, b.memoizedState) || (Ug = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a, b) {
  var c = N, d2 = di(), e2 = b(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c, d2, a), [a]);
  if (d2.getSnapshot !== b || f2 || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d2, e2, b), void 0, null);
    if (null === R)
      throw Error(p(349));
    0 !== (Rh & 30) || ni(c, b, e2);
  }
  return e2;
}
function ni(a, b, c) {
  a.flags |= 16384;
  a = { getSnapshot: b, value: c };
  b = N.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function mi(a, b, c, d2) {
  b.value = c;
  b.getSnapshot = d2;
  oi(b) && pi(a);
}
function ki(a, b, c) {
  return c(function() {
    oi(b) && pi(a);
  });
}
function oi(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d2) {
    return true;
  }
}
function pi(a) {
  var b = Zg(a, 1);
  null !== b && mh(b, a, 1, -1);
}
function qi(a) {
  var b = ci();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b.memoizedState, a];
}
function li(a, b, c, d2) {
  a = { tag: a, create: b, destroy: c, deps: d2, next: null };
  b = N.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d2 = c.next, c.next = a, a.next = d2, b.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b, c, d2) {
  var e2 = ci();
  N.flags |= a;
  e2.memoizedState = li(1 | b, c, void 0, void 0 === d2 ? null : d2);
}
function ui(a, b, c, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g = O.memoizedState;
    f2 = g.destroy;
    if (null !== d2 && Wh(d2, g.deps)) {
      e2.memoizedState = li(b, c, f2, d2);
      return;
    }
  }
  N.flags |= a;
  e2.memoizedState = li(1 | b, c, f2, d2);
}
function vi(a, b) {
  return ti(8390656, 8, a, b);
}
function ji(a, b) {
  return ui(2048, 8, a, b);
}
function wi(a, b) {
  return ui(4, 2, a, b);
}
function xi(a, b) {
  return ui(4, 4, a, b);
}
function yi(a, b) {
  if ("function" === typeof b)
    return a = a(), b(a), function() {
      b(null);
    };
  if (null !== b && void 0 !== b)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function zi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b, a), c);
}
function Ai() {
}
function Bi(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d2 = c.memoizedState;
  if (null !== d2 && null !== b && Wh(b, d2[1]))
    return d2[0];
  c.memoizedState = [a, b];
  return a;
}
function Ci(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d2 = c.memoizedState;
  if (null !== d2 && null !== b && Wh(b, d2[1]))
    return d2[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function Di(a, b, c) {
  if (0 === (Rh & 21))
    return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
  He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
  return b;
}
function Ei(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b();
  } finally {
    C = c, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b, c) {
  var d2 = lh(a);
  c = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b, c);
  else if (c = Yg(a, b, c, d2), null !== c) {
    var e2 = L();
    mh(c, a, d2, e2);
    Ji(c, b, d2);
  }
}
function ri(a, b, c) {
  var d2 = lh(a), e2 = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2))
      try {
        var g = b.lastRenderedState, h2 = f2(g, c);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g)) {
          var k2 = b.interleaved;
          null === k2 ? (e2.next = e2, Xg(b)) : (e2.next = k2.next, k2.next = e2);
          b.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c = Yg(a, b, e2, d2);
    null !== c && (e2 = L(), mh(c, a, d2, e2), Ji(c, b, d2));
  }
}
function Hi(a) {
  var b = a.alternate;
  return a === N || null !== b && b === N;
}
function Ii(a, b) {
  Th = Sh = true;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Ji(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d2 = b.lanes;
    d2 &= a.pendingLanes;
    c |= d2;
    b.lanes = c;
    Cc(a, c);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b) {
  ci().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b, a),
    c
  );
}, useLayoutEffect: function(a, b) {
  return ti(4194308, 4, a, b);
}, useInsertionEffect: function(a, b) {
  return ti(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = ci();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d2 = ci();
  b = void 0 !== c ? c(b) : b;
  d2.memoizedState = d2.baseState = b;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  d2.queue = a;
  a = a.dispatch = Gi.bind(null, N, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b = ci();
  a = { current: a };
  return b.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b, c) {
  var d2 = N, e2 = ci();
  if (I) {
    if (void 0 === c)
      throw Error(p(407));
    c = c();
  } else {
    c = b();
    if (null === R)
      throw Error(p(349));
    0 !== (Rh & 30) || ni(d2, b, c);
  }
  e2.memoizedState = c;
  var f2 = { value: c, getSnapshot: b };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c, b), void 0, null);
  return c;
}, useId: function() {
  var a = ci(), b = R.identifierPrefix;
  if (I) {
    var c = sg;
    var d2 = rg;
    c = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c;
    b = ":" + b + "R" + c;
    c = Uh++;
    0 < c && (b += "H" + c.toString(32));
    b += ":";
  } else
    c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
  return a.memoizedState = b;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b = di();
    return Di(b, O.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b = di().memoizedState;
    return [a, b];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b = di();
  return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b = di().memoizedState;
  return [a, b];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b) {
  try {
    var c = "", d2 = b;
    do
      c += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e2, digest: null };
}
function Li(a, b, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
}
function Mi(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d2 = b.value;
  c.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a, b);
  };
  return c;
}
function Ri(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b.value;
    c.payload = function() {
      return d2(e2);
    };
    c.callback = function() {
      Mi(a, b);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Mi(a, b);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Ti(a, b, c) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b, e2);
  } else
    e2 = d2.get(b), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b, e2));
  e2.has(c) || (e2.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
}
function Vi(a) {
  do {
    var b;
    if (b = 13 === a.tag)
      b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
    if (b)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b, c, d2, e2) {
  if (0 === (a.mode & 1))
    return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b, c, d2) {
  b.child = null === a ? Ch(b, null, c, d2) : Bh(b, a.child, c, d2);
}
function Zi(a, b, c, d2, e2) {
  c = c.render;
  var f2 = b.ref;
  Tg(b, e2);
  d2 = Xh(a, b, c, d2, f2, e2);
  c = bi();
  if (null !== a && !Ug)
    return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e2, $i(a, b, e2);
  I && c && vg(b);
  b.flags |= 1;
  Yi(a, b, d2, e2);
  return b.child;
}
function aj(a, b, c, d2, e2) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b.tag = 15, b.type = f2, cj(a, b, f2, d2, e2);
    a = yh(c.type, null, d2, b, b.mode, e2);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d2) && a.ref === b.ref)
      return $i(a, b, e2);
  }
  b.flags |= 1;
  a = wh(f2, d2);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function cj(a, b, c, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b.ref)
      if (Ug = false, b.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (Ug = true);
      else
        return b.lanes = a.lanes, $i(a, b, e2);
  }
  return dj(a, b, c, d2, e2);
}
function ej(a, b, c) {
  var d2 = b.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b.mode & 1))
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
    else {
      if (0 === (c & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c;
      G(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c, b.memoizedState = null) : d2 = c, G(fj, gj), gj |= d2;
  Yi(a, b, e2, c);
  return b.child;
}
function hj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b.flags |= 512, b.flags |= 2097152;
}
function dj(a, b, c, d2, e2) {
  var f2 = Zf(c) ? Xf : H.current;
  f2 = Yf(b, f2);
  Tg(b, e2);
  c = Xh(a, b, c, d2, f2, e2);
  d2 = bi();
  if (null !== a && !Ug)
    return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e2, $i(a, b, e2);
  I && d2 && vg(b);
  b.flags |= 1;
  Yi(a, b, c, e2);
  return b.child;
}
function ij(a, b, c, d2, e2) {
  if (Zf(c)) {
    var f2 = true;
    cg(b);
  } else
    f2 = false;
  Tg(b, e2);
  if (null === b.stateNode)
    jj(a, b), ph(b, c, d2), rh$1(b, c, d2, e2), d2 = true;
  else if (null === a) {
    var g = b.stateNode, h2 = b.memoizedProps;
    g.props = h2;
    var k2 = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b, g, d2, l2);
    $g = false;
    var r2 = b.memoizedState;
    g.state = r2;
    gh(b, d2, g, e2);
    k2 = b.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b, c, m2, d2), k2 = b.memoizedState), (h2 = $g || oh(b, c, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d2, b.memoizedState = k2), g.props = d2, g.state = k2, g.context = l2, d2 = h2) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d2 = false);
  } else {
    g = b.stateNode;
    bh(a, b);
    h2 = b.memoizedProps;
    l2 = b.type === b.elementType ? h2 : Lg(b.type, h2);
    g.props = l2;
    q2 = b.pendingProps;
    r2 = g.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b, g, d2, k2);
    $g = false;
    r2 = b.memoizedState;
    g.state = r2;
    gh(b, d2, g, e2);
    var n2 = b.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b, c, y2, d2), n2 = b.memoizedState), (l2 = $g || oh(b, c, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d2, b.memoizedState = n2), g.props = d2, g.state = n2, g.context = k2, d2 = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d2 = false);
  }
  return kj(a, b, c, d2, f2, e2);
}
function kj(a, b, c, d2, e2, f2) {
  hj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d2 && !g)
    return e2 && dg(b, c, false), $i(a, b, f2);
  d2 = b.stateNode;
  Xi.current = b;
  var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d2.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Bh(b, a.child, null, f2), b.child = Bh(b, null, h2, f2)) : Yi(a, b, h2, f2);
  b.memoizedState = d2.state;
  e2 && dg(b, c, true);
  return b.child;
}
function lj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
  Ih(a, b.containerInfo);
}
function mj(a, b, c, d2, e2) {
  Ig();
  Jg(e2);
  b.flags |= 256;
  Yi(a, b, c, d2);
  return b.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b, c) {
  var d2 = b.pendingProps, e2 = M.current, f2 = false, g = 0 !== (b.flags & 128), h2;
  (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G(M, e2 & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = qj(g, d2, 0, null), a = Ah(a, d2, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a, b, g, d2, h2, e2, c);
  if (f2) {
    f2 = d2.fallback;
    g = b.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g & 1) && b.child !== e2 ? (d2 = b.child, d2.childLanes = 0, d2.pendingProps = k2, b.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g, c, null), f2.flags |= 2);
    f2.return = b;
    d2.return = b;
    d2.sibling = f2;
    b.child = d2;
    d2 = f2;
    f2 = b.child;
    g = a.child.memoizedState;
    g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a.childLanes & ~c;
    b.memoizedState = nj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b.mode & 1) && (d2.lanes = c);
  d2.return = b;
  d2.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d2;
  b.memoizedState = null;
  return d2;
}
function rj(a, b) {
  b = qj({ mode: "visible", children: b }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function tj(a, b, c, d2) {
  null !== d2 && Jg(d2);
  Bh(b, a.child, null, c);
  a = rj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function sj(a, b, c, d2, e2, f2, g) {
  if (c) {
    if (b.flags & 256)
      return b.flags &= -257, d2 = Li(Error(p(422))), tj(a, b, g, d2);
    if (null !== b.memoizedState)
      return b.child = a.child, b.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g, null);
    f2.flags |= 2;
    d2.return = b;
    f2.return = b;
    d2.sibling = f2;
    b.child = d2;
    0 !== (b.mode & 1) && Bh(b, a.child, null, g);
    b.child.memoizedState = oj(g);
    b.memoizedState = nj;
    return f2;
  }
  if (0 === (b.mode & 1))
    return tj(a, b, g, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p(419));
    d2 = Li(f2, d2, void 0);
    return tj(a, b, g, d2);
  }
  h2 = 0 !== (g & a.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g & -g) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
    }
    uj();
    d2 = Li(Error(p(421)));
    return tj(a, b, g, d2);
  }
  if ("$?" === e2.data)
    return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e2._reactRetry = b, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = rj(b, d2.children);
  b.flags |= 4096;
  return b;
}
function wj(a, b, c) {
  a.lanes |= b;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b);
  Sg(a.return, b, c);
}
function xj(a, b, c, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e2 } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c, f2.tailMode = e2);
}
function yj(a, b, c) {
  var d2 = b.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a, b, d2.children, c);
  d2 = M.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && wj(a, c, b);
          else if (19 === a.tag)
            wj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  G(M, d2);
  if (0 === (b.mode & 1))
    b.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c = b.child;
        for (e2 = null; null !== c; )
          a = c.alternate, null !== a && null === Mh(a) && (e2 = c), c = c.sibling;
        c = e2;
        null === c ? (e2 = b.child, b.child = null) : (e2 = c.sibling, c.sibling = null);
        xj(b, false, e2, c, f2);
        break;
      case "backwards":
        c = null;
        e2 = b.child;
        for (b.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Mh(a)) {
            b.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c;
          c = e2;
          e2 = a;
        }
        xj(b, true, c, null, f2);
        break;
      case "together":
        xj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function jj(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function $i(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  hh |= b.lanes;
  if (0 === (c & b.childLanes))
    return null;
  if (null !== a && b.child !== a.child)
    throw Error(p(153));
  if (null !== b.child) {
    a = b.child;
    c = wh(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling; )
      a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function zj(a, b, c) {
  switch (b.tag) {
    case 3:
      lj(b);
      Ig();
      break;
    case 5:
      Kh$1(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      Ih(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b.type._context, e2 = b.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(M, M.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes))
          return pj(a, b, c);
        G(M, M.current & 1);
        a = $i(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2)
          return yj(a, b, c);
        b.flags |= 128;
      }
      e2 = b.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b.lanes = 0, ej(a, b, c);
  }
  return $i(a, b, c);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b, c, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d2 = A({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c, d2);
    var g;
    c = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g in h2)
            h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g in h2)
              !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k2)
              k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
          } else
            c || (f2 || (f2 = []), f2.push(
              l2,
              c
            )), c = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Dj = function(a, b, c, d2) {
  c !== d2 && (b.flags |= 4);
};
function Ej(a, b) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; )
          null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d2 = null; null !== c; )
          null !== c.alternate && (d2 = c), c = c.sibling;
        null === d2 ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d2 = 0;
  if (b)
    for (var e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c;
  return b;
}
function Fj(a, b, c) {
  var d2 = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;
    case 1:
      return Zf(b.type) && $f(), S(b), null;
    case 3:
      d2 = b.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b);
      S(b);
      return null;
    case 5:
      Lh(b);
      var e2 = Hh(Gh.current);
      c = b.type;
      if (null !== a && null != b.stateNode)
        Cj(a, b, c, d2, e2), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b.stateNode)
            throw Error(p(166));
          S(b);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b)) {
          d2 = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d2[Of] = b;
          d2[Pf] = f2;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c, f2);
          e2 = null;
          for (var g in f2)
            if (f2.hasOwnProperty(g)) {
              var h2 = f2[g];
              "children" === g ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d2);
            }
          switch (c) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b.updateQueue = d2;
          null !== d2 && (b.flags |= 4);
        } else {
          g = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g.createElement(c, { is: d2.is }) : (a = g.createElement(c), "select" === c && (g = a, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d2;
          Aj(a, b, false, false);
          b.stateNode = a;
          a: {
            g = vb(c, d2);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
              }
            switch (c) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;
    case 6:
      if (a && null != b.stateNode)
        Dj(a, b, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b.stateNode)
          throw Error(p(166));
        c = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b)) {
          d2 = b.stateNode;
          c = b.memoizedProps;
          d2[Of] = b;
          if (f2 = d2.nodeValue !== c) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c, 0 !== (a.mode & 1));
              }
          }
          f2 && (b.flags |= 4);
        } else
          d2 = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d2), d2[Of] = b, b.stateNode = d2;
      }
      S(b);
      return null;
    case 13:
      E(M);
      d2 = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
          Hg(), Ig(), b.flags |= 98560, f2 = false;
        else if (f2 = Gg(b), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p(318));
            f2 = b.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p(317));
            f2[Of] = b;
          } else
            Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S(b);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128))
        return b.lanes = c, b;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;
    case 4:
      return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
    case 10:
      return Rg(b.type._context), S(b), null;
    case 17:
      return Zf(b.type) && $f(), S(b), null;
    case 19:
      E(M);
      f2 = b.memoizedState;
      if (null === f2)
        return S(b), null;
      d2 = 0 !== (b.flags & 128);
      g = f2.rendering;
      if (null === g)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b.child; null !== a; ) {
              g = Mh(a);
              if (null !== g) {
                b.flags |= 128;
                Ej(f2, false);
                d2 = g.updateQueue;
                null !== d2 && (b.updateQueue = d2, b.flags |= 4);
                b.subtreeFlags = 0;
                d2 = c;
                for (c = b.child; null !== c; )
                  f2 = c, a = d2, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(M, M.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Hj && (b.flags |= 128, d2 = true, Ej(f2, false), b.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a = Mh(g), null !== a) {
            if (b.flags |= 128, d2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I)
              return S(b), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d2 = true, Ej(f2, false), b.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
      }
      if (null !== f2.tail)
        return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d2 ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b.flags |= 8192), d2 && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b.tag));
}
function Jj(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Lh(b), null;
    case 13:
      E(M);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate)
          throw Error(p(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a, b) {
  var c = a.ref;
  if (null !== c)
    if ("function" === typeof c)
      try {
        c(null);
      } catch (d2) {
        W(a, b, d2);
      }
    else
      c.current = null;
}
function Nj(a, b, c) {
  try {
    c();
  } catch (d2) {
    W(a, b, d2);
  }
}
var Oj = false;
function Pj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d2 = c.getSelection && c.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c || 0 !== e2 && 3 !== q2.nodeType || (h2 = g + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g + d2);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c && ++l2 === e2 && (h2 = g);
                r2 === f2 && ++m2 === d2 && (k2 = g);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c = null;
      }
    c = c || { start: 0, end: 0 };
  } else
    c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V = b; null !== V; )
    if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a)
      a.return = b, V = a;
    else
      for (; null !== V; ) {
        b = V;
        try {
          var n2 = b.alternate;
          if (0 !== (b.flags & 1024))
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x = b.stateNode, w2 = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Lg(b.type, t2), J2);
                  x.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
        } catch (F2) {
          W(b, b.return, F2);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b, c) {
  var d2 = b.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b, c, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d2 = c.create;
        c.destroy = d2();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Sj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Tj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Tj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Uj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Wj(a, b, c) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Wj(a, b, c), a = a.sibling; null !== a; )
      Wj(a, b, c), a = a.sibling;
}
function Xj(a, b, c) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Xj(a, b, c), a = a.sibling; null !== a; )
      Xj(a, b, c), a = a.sibling;
}
var X = null, Yj = false;
function Zj(a, b, c) {
  for (c = c.child; null !== c; )
    ak(a, b, c), c = c.sibling;
}
function ak(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
  switch (c.tag) {
    case 5:
      U || Mj(c, b);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a, b, c);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c.stateNode.containerInfo;
      Yj = true;
      Zj(a, b, c);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Nj(c, b, g) : 0 !== (f2 & 4) && Nj(c, b, g));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a, b, c);
      break;
    case 1:
      if (!U && (Mj(c, b), d2 = c.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c.memoizedProps, d2.state = c.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c, b, h2);
        }
      Zj(a, b, c);
      break;
    case 21:
      Zj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d2 = U) || null !== c.memoizedState, Zj(a, b, c), U = d2) : Zj(a, b, c);
      break;
    default:
      Zj(a, b, c);
  }
}
function bk(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b.forEach(function(b2) {
      var d2 = ck.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d2, d2));
    });
  }
}
function dk(a, b) {
  var c = b.deletions;
  if (null !== c)
    for (var d2 = 0; d2 < c.length; d2++) {
      var e2 = c[d2];
      try {
        var f2 = a, g = b, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p(160));
        ak(f2, g, e2);
        X = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b, l2);
      }
    }
  if (b.subtreeFlags & 12854)
    for (b = b.child; null !== b; )
      ek(b, a), b = b.sibling;
}
function ek(a, b) {
  var c = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b, a);
      fk(a);
      if (d2 & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b, a);
      fk(a);
      d2 & 512 && null !== c && Mj(c, c.return);
      break;
    case 5:
      dk(b, a);
      fk(a);
      d2 & 512 && null !== c && Mj(c, c.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g);
            var l2 = vb(h2, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      dk(b, a);
      fk(a);
      if (d2 & 4) {
        if (null === a.stateNode)
          throw Error(p(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b, a);
      fk(a);
      if (d2 & 4 && null !== c && c.memoizedState.isDehydrated)
        try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      dk(b, a);
      fk(a);
      break;
    case 13:
      dk(b, a);
      fk(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, dk(b, a), U = l2) : dk(b, a);
      fk(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c = r2.return;
                    try {
                      b = d2, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b, a);
      fk(a);
      d2 & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Uj(c)) {
            var d2 = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g = d2.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function ik(a, b, c) {
  V = a;
  jk(a);
}
function jk(a, b, c) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g = null !== e2.memoizedState || Kj;
      if (!g) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g, V = k2) : kk(e2);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U = l2;
      }
      lk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V; ) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772))
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b);
              break;
            case 1:
              var d2 = b.stateNode;
              if (b.flags & 4 && !U)
                if (null === c)
                  d2.componentDidMount();
                else {
                  var e2 = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                  d2.componentDidUpdate(e2, c.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b.updateQueue;
              null !== f2 && ih(b, f2, d2);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child)
                  switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                ih(b, g, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h2;
                var k2 = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l2 = b.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
        U || b.flags & 512 && Sj(b);
      } catch (r2) {
        W(b, b.return, r2);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function hk(a) {
  for (; null !== V; ) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Rj(4, b);
          } catch (k2) {
            W(b, c, k2);
          }
          break;
        case 1:
          var d2 = b.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b, e2, k2);
            }
          }
          var f2 = b.return;
          try {
            Sj(b);
          } catch (k2) {
            W(b, f2, k2);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Sj(b);
          } catch (k2) {
            W(b, g, k2);
          }
      }
    } catch (k2) {
      W(b, b.return, k2);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h2 = b.sibling;
    if (null !== h2) {
      h2.return = b.return;
      V = h2;
      break;
    }
    V = b.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K$1 & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b, c, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p(185));
  Ac(a, c, d2);
  if (0 === (K$1 & 2) || a !== R)
    a === R && (0 === (K$1 & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c && 0 === K$1 && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2)
    null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b = d2 & -d2, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b)
      0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Hk(a, b) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c)
    return null;
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b)
    b = Jk(a, d2);
  else {
    b = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R !== a || Z !== b)
      vk = null, Hj = B() + 500, Lk(a, b);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y ? b = 0 : (R = null, Z = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e2 = xc(a), 0 !== e2 && (d2 = e2, b = Ok(a, e2)));
    if (1 === b)
      throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
    if (6 === b)
      Dk(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b = Jk(a, d2), 2 === b && (f2 = xc(a), 0 !== f2 && (d2 = f2, b = Ok(a, f2))), 1 === b))
        throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d2);
          if ((d2 & 130023424) === d2 && (b = gk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d2);
          if ((d2 & 4194240) === d2)
            break;
          b = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g = 31 - oc(d2);
            f2 = 1 << g;
            g = b[g];
            g > e2 && (e2 = g);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}
function Ok(a, b) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
  a = Jk(a, b);
  2 !== a && (b = uk, uk = c, null !== b && Gj(b));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b = a; ; ) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c))
        for (var d2 = 0; d2 < c.length; d2++) {
          var e2 = c[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c)
      c.return = b, b = c;
    else {
      if (b === a)
        break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a)
          return true;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return true;
}
function Dk(a, b) {
  b &= ~sk;
  b &= ~rk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - oc(b), d2 = 1 << c;
    a[c] = -1;
    b &= ~d2;
  }
}
function Fk(a) {
  if (0 !== (K$1 & 6))
    throw Error(p(327));
  Ik();
  var b = uc(a, 0);
  if (0 === (b & 1))
    return Ek(a, B()), null;
  var c = Jk(a, b);
  if (0 !== a.tag && 2 === c) {
    var d2 = xc(a);
    0 !== d2 && (b = d2, c = Ok(a, d2));
  }
  if (1 === c)
    throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
  if (6 === c)
    throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b) {
  var c = K$1;
  K$1 |= 1;
  try {
    return a(b);
  } finally {
    K$1 = c, 0 === K$1 && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b = K$1;
  K$1 |= 1;
  var c = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a)
      return a();
  } finally {
    C = d2, pk.transition = c, K$1 = b, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d2 = c;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c = c.return;
    }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b = 0; b < Wg.length; b++)
      if (c = Wg[b], d2 = c.interleaved, null !== d2) {
        c.interleaved = null;
        var e2 = d2.next, f2 = c.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e2;
          d2.next = g;
        }
        c.pending = d2;
      }
    Wg = null;
  }
  return a;
}
function Nk(a, b) {
  do {
    var c = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c || null === c.return) {
        T = 1;
        qk = b;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g = c.return, h2 = c, k2 = b;
        b = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g, h2, f2, b);
            y2.mode & 1 && Ti(f2, l2, b);
            b = y2;
            k2 = l2;
            var n2 = b.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b & 1)) {
              Ti(f2, l2, b);
              uj();
              break a;
            }
            k2 = Error(p(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g, h2, f2, b);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b &= -b;
              f2.lanes |= b;
              var x = Oi(f2, k2, b);
              fh(f2, x);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var F2 = Ri(f2, h2, b);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b) {
  var c = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R !== a || Z !== b)
    vk = null, Lk(a, b);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a, e2);
    }
  while (1);
  Qg();
  K$1 = c;
  nk.current = d2;
  if (null !== Y)
    throw Error(p(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a) {
  var b = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b ? Tk(a) : Y = b;
  ok.current = null;
}
function Tk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Fj(c, b, gj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Jj(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Qk(a, b, c) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b, c, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a, b, c, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p(327));
  c = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === R && (Y = R = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c);
    dc();
    K$1 = h2;
    C = g;
    pk.transition = f2;
  } else
    a.current = c;
  wk && (wk = false, xk = a, yk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c.stateNode);
  Ek(a, B());
  if (null !== b)
    for (d2 = a.onRecoverableError, c = 0; c < b.length; c++)
      e2 = b[c], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b = pk.transition, c = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk)
        var d2 = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g)
            g.return = f2, V = g;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x = f2.sibling;
                if (null !== x) {
                  x.return = f2.return;
                  V = x;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2)
            u2.return = g, V = u2;
          else
            b:
              for (g = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c, pk.transition = b;
    }
  }
  return false;
}
function Yk(a, b, c) {
  b = Ki(c, b);
  b = Oi(a, b, 1);
  a = dh(a, b, 1);
  b = L();
  null !== a && (Ac(a, 1, b), Ek(a, b));
}
function W(a, b, c) {
  if (3 === a.tag)
    Yk(a, a, c);
  else
    for (; null !== b; ) {
      if (3 === b.tag) {
        Yk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d2 = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a = Ki(c, a);
          a = Ri(b, a, 1);
          b = dh(b, a, 1);
          a = L();
          null !== b && (Ac(b, 1, a), Ek(b, a));
          break;
        }
      }
      b = b.return;
    }
}
function Ui(a, b, c) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b);
  b = L();
  a.pingedLanes |= a.suspendedLanes & c;
  R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b);
}
function Zk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L();
  a = Zg(a, b);
  null !== a && (Ac(a, b, c), Ek(a, c));
}
function vj(a) {
  var b = a.memoizedState, c = 0;
  null !== b && (c = b.retryLane);
  Zk(a, c);
}
function ck(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d2 && d2.delete(b);
  Zk(a, c);
}
var Wk;
Wk = function(a, b, c) {
  if (null !== a)
    if (a.memoizedProps !== b.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128))
        return Ug = false, zj(a, b, c);
      Ug = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d2 = b.type;
      jj(a, b);
      a = b.pendingProps;
      var e2 = Yf(b, H.current);
      Tg(b, c);
      e2 = Xh(null, b, d2, a, e2, c);
      var f2 = bi();
      b.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d2) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b), e2.updater = nh, b.stateNode = e2, e2._reactInternals = b, rh$1(b, d2, a, c), b = kj(null, b, d2, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Yi(null, b, e2, c), b = b.child);
      return b;
    case 16:
      d2 = b.elementType;
      a: {
        jj(a, b);
        a = b.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b.type = d2;
        e2 = b.tag = $k(d2);
        a = Lg(d2, a);
        switch (e2) {
          case 0:
            b = dj(null, b, d2, a, c);
            break a;
          case 1:
            b = ij(null, b, d2, a, c);
            break a;
          case 11:
            b = Zi(null, b, d2, a, c);
            break a;
          case 14:
            b = aj(null, b, d2, Lg(d2.type, a), c);
            break a;
        }
        throw Error(p(
          306,
          d2,
          ""
        ));
      }
      return b;
    case 0:
      return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b, d2, e2, c);
    case 1:
      return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b, d2, e2, c);
    case 3:
      a: {
        lj(b);
        if (null === a)
          throw Error(p(387));
        d2 = b.pendingProps;
        f2 = b.memoizedState;
        e2 = f2.element;
        bh(a, b);
        gh(b, d2, null, c);
        var g = b.memoizedState;
        d2 = g.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
            e2 = Ki(Error(p(423)), b);
            b = mj(a, b, d2, c, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p(424)), b);
            b = mj(a, b, d2, c, e2);
            break a;
          } else
            for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d2, c), b.child = c; c; )
              c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b = $i(a, b, c);
            break a;
          }
          Yi(a, b, d2, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Kh$1(b), null === a && Eg(b), d2 = b.type, e2 = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e2.children, Ef(d2, e2) ? g = null : null !== f2 && Ef(d2, f2) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return pj(a, b, c);
    case 4:
      return Ih(b, b.stateNode.containerInfo), d2 = b.pendingProps, null === a ? b.child = Bh(b, null, d2, c) : Yi(a, b, d2, c), b.child;
    case 11:
      return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b, d2, e2, c);
    case 7:
      return Yi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d2 = b.type._context;
        e2 = b.pendingProps;
        f2 = b.memoizedProps;
        g = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g;
        if (null !== f2)
          if (He(f2.value, g)) {
            if (f2.children === e2.children && !Wf.current) {
              b = $i(a, b, c);
              break a;
            }
          } else
            for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c & -c);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c);
                    Sg(
                      f2.return,
                      c,
                      b
                    );
                    h2.lanes |= c;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g = f2.type === b.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g)
                  throw Error(p(341));
                g.lanes |= c;
                h2 = g.alternate;
                null !== h2 && (h2.lanes |= c);
                Sg(g, c, b);
                g = f2.sibling;
              } else
                g = f2.child;
              if (null !== g)
                g.return = f2;
              else
                for (g = f2; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f2 = g.sibling;
                  if (null !== f2) {
                    f2.return = g.return;
                    g = f2;
                    break;
                  }
                  g = g.return;
                }
              f2 = g;
            }
        Yi(a, b, e2.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e2 = b.type, d2 = b.pendingProps.children, Tg(b, c), e2 = Vg(e2), d2 = d2(e2), b.flags |= 1, Yi(a, b, d2, c), b.child;
    case 14:
      return d2 = b.type, e2 = Lg(d2, b.pendingProps), e2 = Lg(d2.type, e2), aj(a, b, d2, e2, c);
    case 15:
      return cj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b), b.tag = 1, Zf(d2) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d2, e2), rh$1(b, d2, e2, c), kj(null, b, d2, true, a, c);
    case 19:
      return yj(a, b, c);
    case 22:
      return ej(a, b, c);
  }
  throw Error(p(156, b.tag));
};
function Gk(a, b) {
  return ac(a, b);
}
function al(a, b, c, d2) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d2) {
  return new al(a, b, c, d2);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a)
    return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function wh(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function yh(a, b, c, d2, e2, f2) {
  var g = 2;
  d2 = a;
  if ("function" === typeof a)
    bj(a) && (g = 1);
  else if ("string" === typeof a)
    g = 5;
  else
    a:
      switch (a) {
        case ya:
          return Ah(c.children, e2, f2, b);
        case za:
          g = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c, b, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c, b, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return qj(c, e2, f2, b);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d2 = null;
                break a;
            }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
  b = Bg(g, c, b, e2);
  b.elementType = a;
  b.type = d2;
  b.lanes = f2;
  return b;
}
function Ah(a, b, c, d2) {
  a = Bg(7, a, d2, b);
  a.lanes = c;
  return a;
}
function qj(a, b, c, d2) {
  a = Bg(22, a, d2, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function zh(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function bl(a, b, c, d2, e2) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b, c, d2, e2, f2, g, h2, k2) {
  a = new bl(a, b, c, h2, k2);
  1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
  f2 = Bg(3, null, null, b);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b, c) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b, implementation: c };
}
function el(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c))
      return bg(a, c, b);
  }
  return b;
}
function fl(a, b, c, d2, e2, f2, g, h2, k2) {
  a = cl(c, d2, true, a, e2, f2, g, h2, k2);
  a.context = el(null);
  c = a.current;
  d2 = L();
  e2 = lh(c);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b && null !== b ? b : null;
  dh(c, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Ek(a, d2);
  return a;
}
function gl(a, b, c, d2) {
  var e2 = b.current, f2 = L(), g = lh(e2);
  c = el(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = ch(f2, g);
  b.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b.callback = d2);
  a = dh(e2, b, g);
  null !== a && (mh(a, e2, g, f2), eh(a, e2, g));
  return g;
}
function hl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function jl(a, b) {
  il(a, b);
  (a = a.alternate) && il(a, b);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b = this._internalRoot;
  if (null === b)
    throw Error(p(409));
  gl(a, b, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b = Hc();
    a = { blockedOn: null, target: a, priority: b };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++)
      ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b, c, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = hl(g);
        f2.call(a2);
      };
    }
    var g = fl(b, d2, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b, k2, c, d2);
  });
  return k2;
}
function sl(a, b, c, d2, e2) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = hl(g);
        h2.call(a2);
      };
    }
    gl(b, g, a, e2);
  } else
    g = rl(c, b, a, e2, d2);
  return hl(g);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K$1 & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b2 = Zg(a, 1);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 1, c2);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b = Zg(a, 134217728);
    if (null !== b) {
      var c = L();
      mh(b, a, 134217728, c);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b = lh(a), c = Zg(a, b);
    if (null !== c) {
      var d2 = L();
      mh(c, a, b, d2);
    }
    jl(a, b);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d2 = c[b];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b))
    throw Error(p(200));
  return dl(a, b, null, c);
};
reactDom_production_min.createRoot = function(a, b) {
  if (!ol(a))
    throw Error(p(299));
  var c = false, d2 = "", e2 = ll;
  null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d2 = b.identifierPrefix), void 0 !== b.onRecoverableError && (e2 = b.onRecoverableError));
  b = cl(a, 1, false, null, null, c, false, d2, e2);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render)
      throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!pl(b))
    throw Error(p(200));
  return sl(null, a, b, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b, c) {
  if (!ol(a))
    throw Error(p(405));
  var d2 = null != c && c.hydratedSources || null, e2 = false, f2 = "", g = ll;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e2 = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = fl(b, null, a, 1, null != c ? c : null, e2, false, f2, g);
  a[uf] = b.current;
  sf(a);
  if (d2)
    for (a = 0; a < d2.length; a++)
      c = d2[a], e2 = c._getVersion, e2 = e2(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e2] : b.mutableSourceEagerHydrationData.push(
        c,
        e2
      );
  return new nl(b);
};
reactDom_production_min.render = function(a, b, c) {
  if (!pl(b))
    throw Error(p(200));
  return sl(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a))
    throw Error(p(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d2) {
  if (!pl(c))
    throw Error(p(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p(38));
  return sl(a, b, c, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m = reactDomExports;
{
  client.createRoot = m.createRoot;
  client.hydrateRoot = m.hydrateRoot;
}
/**
 * @remix-run/router v1.14.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key2) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$1({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key2 || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$1({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base2);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n2, i) => n2 === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = safelyDecodeURIComponent(value || "", paramName);
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map((match) => match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$1({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.21.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback", false);
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
const alreadyWarned = {};
function warningOnce(key2, cond, message) {
  if (!cond && !alreadyWarned[key2]) {
    alreadyWarned[key2] = true;
  }
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key: key2 = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key: key2
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key2, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.21.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function Icons({
  color,
  size = 16,
  name,
  className = "",
  ratio = 1,
  strokeWidth = 1.5
}) {
  let icons = {
    info: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 20 20",
        fill: `none`,
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10 18.3334C14.6024 18.3334 18.3333 14.6024 18.3333 10C18.3333 5.39765 14.6024 1.66669 10 1.66669C5.39763 1.66669 1.66667 5.39765 1.66667 10C1.66667 14.6024 5.39763 18.3334 10 18.3334Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10 13.3333V10",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10 6.66669H10.0083",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    clock: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 6V12L16 14",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    bell: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 16 16",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 5.33331C12 4.27245 11.5786 3.25503 10.8284 2.50489C10.0783 1.75474 9.06087 1.33331 8 1.33331C6.93913 1.33331 5.92172 1.75474 5.17157 2.50489C4.42143 3.25503 4 4.27245 4 5.33331C4 9.99998 2 11.3333 2 11.3333H14C14 11.3333 12 9.99998 12 5.33331Z",
              className: `stroke-current ${color}`,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.15335 14C9.03614 14.2021 8.86791 14.3698 8.6655 14.4864C8.46309 14.6029 8.2336 14.6643 8.00001 14.6643C7.76643 14.6643 7.53694 14.6029 7.33453 14.4864C7.13212 14.3698 6.96389 14.2021 6.84668 14",
              className: `stroke-current ${color}`,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    chevron: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: 10 * ratio,
        height: 6 * ratio,
        viewBox: "0 0 10 6",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M1 1L5 5L9 1",
            className: `stroke-current text-${color}`,
            strokeWidth,
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    arrowAlt: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: size || "14",
        height: size || "18",
        viewBox: "0 0 14 18",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M7 1L7 17M7 17L1 11M7 17L13 11",
            stroke: "#403F3F",
            strokeWidth,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            className: `stroke-current text-${color}`
          }
        )
      }
    ),
    arrow: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19 12H5",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 19L5 12L12 5",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    copy: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M20 9H11C9.89543 9 9 9.89543 9 11V20C9 21.1046 9.89543 22 11 22H20C21.1046 22 22 21.1046 22 20V11C22 9.89543 21.1046 9 20 9Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5 15H4C3.46957 15 2.96086 14.7893 2.58579 14.4142C2.21071 14.0391 2 13.5304 2 13V4C2 3.46957 2.21071 2.96086 2.58579 2.58579C2.96086 2.21071 3.46957 2 4 2H13C13.5304 2 14.0391 2.21071 14.4142 2.58579C14.7893 2.96086 15 3.46957 15 4V5",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    paste: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 18 18",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 3H13.5C13.8978 3 14.2794 3.15804 14.5607 3.43934C14.842 3.72064 15 4.10218 15 4.5V15C15 15.3978 14.842 15.7794 14.5607 16.0607C14.2794 16.342 13.8978 16.5 13.5 16.5H4.5C4.10218 16.5 3.72064 16.342 3.43934 16.0607C3.15804 15.7794 3 15.3978 3 15V4.5C3 4.10218 3.15804 3.72064 3.43934 3.43934C3.72064 3.15804 4.10218 3 4.5 3H6",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.25 1.5H6.75C6.33579 1.5 6 1.83579 6 2.25V3.75C6 4.16421 6.33579 4.5 6.75 4.5H11.25C11.6642 4.5 12 4.16421 12 3.75V2.25C12 1.83579 11.6642 1.5 11.25 1.5Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    menu: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 16 16",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2 12H14",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2 8H14",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2 4H14",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    circle: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 9 8",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_78_2899)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.49996 7.33335C6.34091 7.33335 7.83329 5.84097 7.83329 4.00002C7.83329 2.15907 6.34091 0.666687 4.49996 0.666687C2.65901 0.666687 1.16663 2.15907 1.16663 4.00002C1.16663 5.84097 2.65901 7.33335 4.49996 7.33335Z",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_78_2899", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: size, height: size, fill: "white", transform: "translate(0.5)" }) }) })
        ]
      }
    ),
    telegram: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.6667 1.33334L7.33337 8.66668",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.6667 1.33334L10 14.6667L7.33337 8.66668L1.33337 6.00001L14.6667 1.33334Z",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    dollar: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 17 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_316_662)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M8.5 0.666656V15.3333",
                className: `stroke-current text-${color}`,
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M11.8333 3.33334H6.83333C6.21449 3.33334 5.621 3.57918 5.18342 4.01676C4.74583 4.45435 4.5 5.04784 4.5 5.66668C4.5 6.28552 4.74583 6.87901 5.18342 7.31659C5.621 7.75418 6.21449 8.00001 6.83333 8.00001H10.1667C10.7855 8.00001 11.379 8.24584 11.8166 8.68343C12.2542 9.12101 12.5 9.7145 12.5 10.3333C12.5 10.9522 12.2542 11.5457 11.8166 11.9833C11.379 12.4208 10.7855 12.6667 10.1667 12.6667H4.5",
                className: `stroke-current text-${color}`,
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_316_662", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "16", height: "16", fill: "white", transform: "translate(0.5)" }) }) })
        ]
      }
    ),
    refresh: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_316_729)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M15.3333 13.3333V9.33334H11.3333",
                className: `stroke-current text-${color}`,
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0.666687 2.66666V6.66666H4.66669",
                className: `stroke-current text-${color}`,
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M13.66 6.00001C13.3219 5.04453 12.7473 4.19028 11.9897 3.51696C11.2322 2.84363 10.3164 2.37319 9.32783 2.14952C8.33928 1.92584 7.31018 1.95624 6.33656 2.23786C5.36294 2.51948 4.47652 3.04315 3.76002 3.76001L0.666687 6.66668M15.3334 9.33334L12.24 12.24C11.5235 12.9569 10.6371 13.4805 9.66348 13.7622C8.68986 14.0438 7.66076 14.0742 6.67221 13.8505C5.68366 13.6268 4.76789 13.1564 4.01033 12.4831C3.25278 11.8097 2.67813 10.9555 2.34002 10",
                className: `stroke-current text-${color}`,
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_316_729", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "16", height: "16", fill: "white" }) }) })
        ]
      }
    ),
    cross: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 4L4 12",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4 4L12 12",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    qr: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 15 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { "clip-path": "url(#clip0_664_1376)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0.5 0.4375C0.5 0.321468 0.546094 0.210188 0.628141 0.128141C0.710188 0.0460936 0.821468 0 0.9375 0L3.5625 0C3.67853 0 3.78981 0.0460936 3.87186 0.128141C3.95391 0.210188 4 0.321468 4 0.4375C4 0.553532 3.95391 0.664812 3.87186 0.746859C3.78981 0.828906 3.67853 0.875 3.5625 0.875H1.375V3.0625C1.375 3.17853 1.32891 3.28981 1.24686 3.37186C1.16481 3.45391 1.05353 3.5 0.9375 3.5C0.821468 3.5 0.710188 3.45391 0.628141 3.37186C0.546094 3.28981 0.5 3.17853 0.5 3.0625V0.4375ZM11 0.4375C11 0.321468 11.0461 0.210188 11.1281 0.128141C11.2102 0.0460936 11.3215 0 11.4375 0L14.0625 0C14.1785 0 14.2898 0.0460936 14.3719 0.128141C14.4539 0.210188 14.5 0.321468 14.5 0.4375V3.0625C14.5 3.17853 14.4539 3.28981 14.3719 3.37186C14.2898 3.45391 14.1785 3.5 14.0625 3.5C13.9465 3.5 13.8352 3.45391 13.7531 3.37186C13.6711 3.28981 13.625 3.17853 13.625 3.0625V0.875H11.4375C11.3215 0.875 11.2102 0.828906 11.1281 0.746859C11.0461 0.664812 11 0.553532 11 0.4375ZM0.9375 10.5C1.05353 10.5 1.16481 10.5461 1.24686 10.6281C1.32891 10.7102 1.375 10.8215 1.375 10.9375V13.125H3.5625C3.67853 13.125 3.78981 13.1711 3.87186 13.2531C3.95391 13.3352 4 13.4465 4 13.5625C4 13.6785 3.95391 13.7898 3.87186 13.8719C3.78981 13.9539 3.67853 14 3.5625 14H0.9375C0.821468 14 0.710188 13.9539 0.628141 13.8719C0.546094 13.7898 0.5 13.6785 0.5 13.5625V10.9375C0.5 10.8215 0.546094 10.7102 0.628141 10.6281C0.710188 10.5461 0.821468 10.5 0.9375 10.5ZM14.0625 10.5C14.1785 10.5 14.2898 10.5461 14.3719 10.6281C14.4539 10.7102 14.5 10.8215 14.5 10.9375V13.5625C14.5 13.6785 14.4539 13.7898 14.3719 13.8719C14.2898 13.9539 14.1785 14 14.0625 14H11.4375C11.3215 14 11.2102 13.9539 11.1281 13.8719C11.0461 13.7898 11 13.6785 11 13.5625C11 13.4465 11.0461 13.3352 11.1281 13.2531C11.2102 13.1711 11.3215 13.125 11.4375 13.125H13.625V10.9375C13.625 10.8215 13.6711 10.7102 13.7531 10.6281C13.8352 10.5461 13.9465 10.5 14.0625 10.5ZM4 3.5H4.875V4.375H4V3.5Z",
                className: `fill-current text-${color}`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M6.625 1.75H2.25V6.125H6.625V1.75ZM3.125 2.625H5.75V5.25H3.125V2.625ZM4.875 9.625H4V10.5H4.875V9.625Z",
                className: `fill-current text-${color}`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M6.625 7.875H2.25V12.25H6.625V7.875ZM3.125 8.75H5.75V11.375H3.125V8.75ZM10.125 3.5H11V4.375H10.125V3.5Z",
                className: `fill-current text-${color}`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M8.375 1.75H12.75V6.125H8.375V1.75ZM9.25 2.625V5.25H11.875V2.625H9.25ZM7.5 7V8.75H8.375V9.625H7.5V10.5H9.25V8.75H10.125V10.5H11V9.625H12.75V8.75H10.125V7H7.5ZM9.25 8.75H8.375V7.875H9.25V8.75ZM12.75 10.5H11.875V11.375H10.125V12.25H12.75V10.5ZM9.25 12.25V11.375H7.5V12.25H9.25Z",
                className: `fill-current text-${color}`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 7.875H12.75V7H11V7.875Z", className: `fill-current text-${color}` })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_664_1376", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "14", height: "14", fill: "white", transform: "translate(0.5)" }) }) })
        ]
      }
    ),
    plus: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7 2.91675V11.0834",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.91675 7H11.0834",
              className: `stroke-current text-${color}`,
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    "log-out": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.33325 9.91659L12.2499 6.99992L9.33325 4.08325",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.25 7H5.25",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.25 12.25H2.91667C2.60725 12.25 2.3105 12.1271 2.09171 11.9083C1.87292 11.6895 1.75 11.3928 1.75 11.0833V2.91667C1.75 2.60725 1.87292 2.3105 2.09171 2.09171C2.3105 1.87292 2.60725 1.75 2.91667 1.75H5.25",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    swap: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "16",
        height: "18",
        className,
        viewBox: "0 0 16 18",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.66667 13.4444L6.33334 9M6.33334 9L10 13.4444M6.33334 9L6.33334 17",
              strokeWidth,
              className: `stroke-current text-${color}`,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M6.57853 4.07827C6.31493 3.75875 5.84223 3.71343 5.52271 3.97703C5.2032 4.24062 5.15787 4.71333 5.42147 5.03284L6.57853 4.07827ZM9.66667 9L9.08814 9.47729C9.23061 9.64998 9.44278 9.75 9.66667 9.75C9.89055 9.75 10.1027 9.64998 10.2452 9.47729L9.66667 9ZM13.9119 5.03284C14.1755 4.71333 14.1301 4.24062 13.8106 3.97703C13.4911 3.71343 13.0184 3.75875 12.7548 4.07827L13.9119 5.03284ZM10.4167 0.999999C10.4167 0.585786 10.0809 0.249999 9.66667 0.249999C9.25245 0.249999 8.91667 0.585786 8.91667 0.999999L10.4167 0.999999ZM5.42147 5.03284L9.08814 9.47729L10.2452 8.52271L6.57853 4.07827L5.42147 5.03284ZM10.2452 9.47729L13.9119 5.03284L12.7548 4.07827L9.08814 8.52271L10.2452 9.47729ZM10.4167 9L10.4167 0.999999L8.91667 0.999999L8.91667 9L10.4167 9Z",
              className: `fill-current text-${color}`
            }
          )
        ]
      }
    ),
    dot: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "4",
        height: "4",
        className,
        viewBox: "0 0 4 4",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M2.3165 3.918C1.9965 3.918 1.7045 3.844 1.4405 3.696C1.1765 3.548 0.9665 3.346 0.8105 3.09C0.6585 2.83 0.5825 2.54 0.5825 2.22C0.5825 1.896 0.6605 1.606 0.8165 1.35C0.9725 1.09 1.1805 0.888 1.4405 0.744C1.7005 0.596 1.9925 0.522 2.3165 0.522C2.6165 0.522 2.8925 0.596 3.1445 0.744C3.4005 0.888 3.6045 1.09 3.7565 1.35C3.9085 1.606 3.9845 1.896 3.9845 2.22C3.9845 2.54 3.9085 2.83 3.7565 3.09C3.6045 3.346 3.4005 3.548 3.1445 3.696C2.8925 3.844 2.6165 3.918 2.3165 3.918Z",
            fill: "#64748B"
          }
        )
      }
    ),
    search: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        className,
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.16667 15.8333C12.8486 15.8333 15.8333 12.8486 15.8333 9.16667C15.8333 5.48477 12.8486 2.5 9.16667 2.5C5.48477 2.5 2.5 5.48477 2.5 9.16667C2.5 12.8486 5.48477 15.8333 9.16667 15.8333Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M17.5 17.5L13.875 13.875",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    eye: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_745_1719)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0.833344 10.0002C0.833344 10.0002 4.16668 3.3335 10 3.3335C15.8333 3.3335 19.1667 10.0002 19.1667 10.0002C19.1667 10.0002 15.8333 16.6668 10 16.6668C4.16668 16.6668 0.833344 10.0002 0.833344 10.0002Z",
                className: `stroke-current text-${color}`,
                strokeWidth,
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M10 12.5C11.3807 12.5 12.5 11.3807 12.5 10C12.5 8.61929 11.3807 7.5 10 7.5C8.61929 7.5 7.5 8.61929 7.5 10C7.5 11.3807 8.61929 12.5 10 12.5Z",
                className: `stroke-current text-${color}`,
                strokeWidth,
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_745_1719", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "20", height: "20", fill: "white" }) }) })
        ]
      }
    ),
    checkmark: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "10",
        viewBox: "0 0 14 10",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12.3332 1L4.99984 8.33333L1.6665 5",
            className: `stroke-current text-${color}`,
            strokeWidth,
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    "more-vertical": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.99992 13.3333C8.36811 13.3333 8.66659 13.0349 8.66659 12.6667C8.66659 12.2985 8.36811 12 7.99992 12C7.63173 12 7.33325 12.2985 7.33325 12.6667C7.33325 13.0349 7.63173 13.3333 7.99992 13.3333Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.99992 8.66659C8.36811 8.66659 8.66659 8.36811 8.66659 7.99992C8.66659 7.63173 8.36811 7.33325 7.99992 7.33325C7.63173 7.33325 7.33325 7.63173 7.33325 7.99992C7.33325 8.36811 7.63173 8.66659 7.99992 8.66659Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.99992 4.00008C8.36811 4.00008 8.66659 3.7016 8.66659 3.33341C8.66659 2.96522 8.36811 2.66675 7.99992 2.66675C7.63173 2.66675 7.33325 2.96522 7.33325 3.33341C7.33325 3.7016 7.63173 4.00008 7.99992 4.00008Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    question: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 20 20",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.99984 18.3334C14.6022 18.3334 18.3332 14.6025 18.3332 10.0001C18.3332 5.39771 14.6022 1.66675 9.99984 1.66675C5.39746 1.66675 1.6665 5.39771 1.6665 10.0001C1.6665 14.6025 5.39746 18.3334 9.99984 18.3334Z",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10 14.1667H10.0083",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.5752 7.49999C7.77112 6.94304 8.15782 6.47341 8.66682 6.17426C9.17583 5.87512 9.77427 5.76577 10.3562 5.86558C10.9381 5.96539 11.4659 6.26792 11.8461 6.71959C12.2263 7.17126 12.4344 7.74292 12.4335 8.33332C12.4335 9.99999 9.93353 10.8333 9.93353 10.8333",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    maximize: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 17 16",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M6.5 14H2.5V10",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.5 14L7.16667 9.33334",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.5 2H14.5V6",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.5002 2L9.8335 6.66667",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    minimize: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 20 20",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M3.33301 11.6667H8.33301V16.6667",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.5 17.5L8.33333 11.6667",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16.667 8.33334H11.667V3.33334",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.667 8.33333L17.5003 2.5",
              className: `stroke-current text-${color}`,
              strokeWidth,
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    settings: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4 6C4 6 9.57574 6 13 6M16 4V6M16 8V6M16 6H20",
              className: `stroke-current text-${color}`,
              strokeWidth,
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4 18C4 18 6.57574 18 10 18M13 16V18M13 20V18M13 18H20",
              className: `stroke-current text-${color}`,
              strokeWidth,
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M20 12C20 12 14.4243 12 11 12M8 14L8 12M8 10L8 12M8 12L4 12",
              className: `stroke-current text-${color}`,
              strokeWidth,
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }
          )
        ]
      }
    ),
    delete: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6", y: "7", width: "12", height: "13", rx: "2", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 11V16", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 11V16", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 20L16 21", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 20L8 21", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 4C10 3.44772 10.4477 3 11 3H13C13.5523 3 14 3.44772 14 4V7H10V4Z", stroke: "#403F3F", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
        ]
      }
    ),
    "file-upload": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "24",
        height: size || "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: `stroke-current text-${color}`, d: "M13.5 3H12H7C5.89543 3 5 3.89543 5 5V19C5 20.1046 5.89543 21 7 21H7.5M13.5 3L19 8.625M13.5 3V7.625C13.5 8.17728 13.9477 8.625 14.5 8.625H19M19 8.625V9.75V12V19C19 20.1046 18.1046 21 17 21H16.5", stroke: "#9A9898", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 21L12 13M12 13L14.5 15.5M12 13L9.5 15.5", stroke: "#9A9898", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 21L12 13M12 13L14.5 15.5M12 13L9.5 15.5", stroke: "#9A9898", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
        ]
      }
    ),
    "token-logo": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "16",
        height: size || "16",
        viewBox: "0 0 16 16",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0.5", y: "0.5", width: "15", height: "15", rx: "7.5", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { "clip-path": "url(#clip0_1062_2235)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.247 2.66675H8.74902V13.3334H10.247V2.66675Z", fill: "#EB2020" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.2641 2.66675H5.76611V13.3334H7.2641V2.66675Z", fill: "#EB2020" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.3334 8.74902H2.66675V10.247H13.3334V8.74902Z", fill: "#EB2020" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.3334 5.76611H2.66675V7.2641H13.3334V5.76611Z", fill: "#EB2020" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.7321 4.26807H4.26807V11.7321H11.7321V4.26807Z", fill: "#EB2020" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.2471 7.26392H5.76611V8.74898H10.2471V7.26392Z", fill: "white" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.74898 5.76611H7.26392V10.2471H8.74898V5.76611Z", fill: "white" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0.5", y: "0.5", width: "15", height: "15", rx: "7.5", stroke: "#F2F0F0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_1062_2235", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              width: "10.6667",
              height: "10.6667",
              fill: "white",
              transform: "translate(2.66675 2.66675)"
            }
          ) }) })
        ]
      }
    ),
    "swtr-logo": /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: size || "36",
        height: size || "36",
        viewBox: "0 0 36 36",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.46 0H15.5157V5.40436H20.5278V0H25.5835V5.40436H30.5956V10.46H36V15.5157H30.5956V20.5278H36V25.5835H30.5956V30.5956H25.5835V36H20.5278V30.5956H15.5157V36H10.46V30.5956H5.40436V25.5835H0V20.5278H5.40436V15.5157H0V10.46H5.40436V5.40436H10.46V0ZM20.5278 10.46H15.5157V15.5157H10.46V20.5278H15.5157V25.5835H20.5278V20.5278H25.5835V15.5157H20.5278V10.46Z", fill: "#DA291C" })
      }
    ),
    "bitcoin-logo": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "16",
        height: size || "16",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          "className=",
          className,
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8", cy: "8", r: "7.5", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8", cy: "8", r: "7.5", fill: "url(#pattern0)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8", cy: "8", r: "7.5", stroke: "#F2F0F0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pattern", { id: "pattern0", patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_1062_2371", transform: "scale(0.005)" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "image",
              {
                id: "image0_1062_2371",
                width: "200",
                height: "200",
                xlinkHref: "data:image/png;base64,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"
              }
            )
          ] })
        ]
      }
    ),
    "binance-logo": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "36",
        height: size || "36",
        viewBox: "0 0 36 36",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0.5", y: "0.5", width: "35", height: "35", rx: "17.5", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { "clip-path": "url(#clip0_1120_1363)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 0.75C27.5276 0.75 35.25 8.47242 35.25 18C35.25 27.5276 27.5276 35.25 18 35.25C8.47242 35.25 0.75 27.5276 0.75 18C0.75 8.47242 8.47242 0.75 18 0.75Z", fill: "#F0B90B" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.2305 18L10.243 22.5613L14.1187 24.842V27.5124L7.97477 23.909V16.6662L10.2305 18ZM10.2305 13.4387V16.0967L7.97339 14.7615V12.1035L10.2305 10.7683L12.4987 12.1035L10.2305 13.4387ZM15.7373 12.1035L17.9944 10.7683L20.2626 12.1035L17.9944 13.4387L15.7373 12.1035Z", fill: "white" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.8616 21.6159V18.9455L14.1187 20.2807V22.9387L11.8616 21.6159ZM15.7373 25.7985L17.9944 27.1337L20.2627 25.7985V28.4565L17.9944 29.7917L15.7373 28.4565V25.7985ZM23.4998 12.1035L25.7569 10.7683L28.0252 12.1035V14.7615L25.7569 16.0967V13.4387L23.4998 12.1035ZM25.7569 22.5613L25.7694 18L28.0265 16.6648V23.9076L21.8826 27.511V24.8406L25.7569 22.5613Z", fill: "white" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.1384 21.6159L21.8812 22.9386V20.2807L24.1384 18.9454V21.6159Z", fill: "white" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.1384 14.3842L24.1508 17.0546L20.264 19.3352V23.9076L18.0069 25.2304L15.7497 23.9076V19.3352L11.863 17.0546V14.3842L14.1298 13.0489L17.9931 15.3406L21.8798 13.0489L24.1481 14.3842H24.1384ZM11.8616 9.82424L17.9944 6.20837L24.1384 9.82424L21.8812 11.1595L17.9944 8.86775L14.1187 11.1595L11.8616 9.82424Z", fill: "white" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0.5", y: "0.5", width: "35", height: "35", rx: "17.5", stroke: "#F2F0F0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_1120_1363", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "34.5", height: "34.5", fill: "white", transform: "translate(0.75 0.75)" }) }) })
        ]
      }
    ),
    "moon-pay-logo": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "36",
        height: size || "36",
        viewBox: "0 0 36 36",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 18C0 8.05888 8.05888 0 18 0C27.9411 0 36 8.05888 36 18C36 27.9411 27.9411 36 18 36C8.05888 36 0 27.9411 0 18Z", fill: "url(#pattern2)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pattern", { id: "pattern2", patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_1120_1249", transform: "scale(0.0108696)" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "image",
              {
                id: "image0_1120_1249",
                width: "92",
                height: "92",
                xlinkHref: "data:image/png;base64,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"
              }
            )
          ] })
        ]
      }
    ),
    "mercuryo-logo": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "36",
        height: "36",
        viewBox: "0 0 36 36",
        fill: "none",
        className,
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "36", height: "36", rx: "18", fill: "url(#pattern1)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pattern", { id: "pattern1", patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_1120_2900", transform: "scale(0.00104167)" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "image",
              {
                id: "image0_1120_2900",
                width: "960",
                height: "960",
                xlinkHref: "data:image/png;base64,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AhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1agmUQAmUQAmUQAmUQAlUQLcNlEAJlEAJlEAJlEAJlMAEAhXQE2A1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"
              }
            )
          ] })
        ]
      }
    ),
    "swtr-example-service": /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "48",
        height: size || "48",
        viewBox: "0 0 49 48",
        className,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0.5 24C0.5 10.7452 11.2452 0 24.5 0C37.7548 0 48.5 10.7452 48.5 24C48.5 37.2548 37.7548 48 24.5 48C11.2452 48 0.5 37.2548 0.5 24Z", fill: "#E6E5E5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.4734 12H22.8438V15.6029H26.1852V12H29.5557V15.6029H32.8971V18.9734H36.5V22.3438H32.8971V25.6852H36.5V29.0557H32.8971V32.3971H29.5557V36H26.1852V32.3971H22.8438V36H19.4734V32.3971H16.1029V29.0557H12.5V25.6852H16.1029V22.3438H12.5V18.9734H16.1029V15.6029H19.4734V12ZM26.1852 18.9734H22.8438V22.3438H19.4734V25.6852H22.8438V29.0557H26.1852V25.6852H29.5557V22.3438H26.1852V18.9734Z", fill: "#3D3D3D" })
        ]
      }
    ),
    attentionMark: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size || "20",
        height: size || "20",
        className,
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.44722 16.1056L8.21115 2.57771C8.94819 1.10361 11.0518 1.10362 11.7889 2.57771L18.5528 16.1056C19.2177 17.4354 18.2507 19 16.7639 19H3.23607C1.7493 19 0.782315 17.4354 1.44722 16.1056Z", stroke: "#0D0C0C", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10", cy: "15", r: "1", fill: "#0D0C0C" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 8L10 12", stroke: "#0D0C0C", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
        ]
      }
    )
  };
  const iconsProp = name;
  return icons[iconsProp];
}
const NotFoundImage = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: "not-found-image",
      width: "388",
      height: "389",
      viewBox: "0 0 388 389",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { y: "0.5", width: "388", height: "388", fill: "url(#pattern0)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("pattern", { id: "pattern0", patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_1815_19503", transform: "scale(0.002)" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "image",
            {
              id: "image0_1815_19503",
              width: "500",
              height: "500",
              xlinkHref: "data:image/png;base64,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"
            }
          )
        ] })
      ]
    }
  ) });
};
const NotFoundPage = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "not-found-page flex flex-col items-center py-32", id: "notFoundPage", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "mb-12 text-center font-bold uppercase text-white sm:text-[32px] sm:leading-snug lg:text-5xl/[67.2px]", children: [
      "Page not found ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-center font-medium text-primary sm:text-xl lg:text-4xl", children: "Error 404" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animation_404__block not-found-image mb-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotFoundImage, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "flex justify-center text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mr-2 text-right", children: [
        "Go to ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        " Main page"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { color: "kyc-primary-dark", name: "arrowAlt" })
    ] })
  ] }) });
};
const index = "";
const mainHeading = `text-xl font-semibold leading-tight text-kyc-primary-dark`;
const pageHeading = `text-base font-bold leading-tight text-kyc-primary-dark`;
const subHeading = `text-base font-medium leading-snug text-kyc-primary-dark`;
const contentHeading = `text-sm font-semibold leading-tigh text-kyc-secondary-grey`;
const baseText = `text-sm text-kyc-secondary-grey font-normal leading-snug`;
const navMenuHeading = `text-base font-medium leading-snug text-kyc-secondary-dark`;
const navMenuDesctiption = `text-small font-medium leading-4 text-kyc-secondary-grey`;
const baseDescription = `text-xs font-medium leading-snug text-kyc-secondary-grey`;
const tableCaption = `text-base font-medium leading-snug text-kyc-secondary-dark`;
const tableValue = `text-sm font-bold leading-snug text-kyc-secondary-dark`;
const baseLabel = `text-sm font-medium text-kyc-secondary-grey`;
const baseInput = `pl-0 placeholder-neutral-300 !text-base border-transparent focus:border-transparent border-b-kyc-border-dark focus:border-b-kyc-border-dark`;
const nativeSelect = `bg-transparent leading-snug font-normal mt-2 mb-2.5 outline-none`;
const actionBtnAccent = `!rounded-3xl !bg-kyc-primary border-kyc-primary-dark !font-medium self-end max-h-11 mb-6`;
const actionBtnDisabled = `!rounded-3xl !font-medium self-end max-h-11 mb-6`;
const modalBottomOverlay = `h-screen w-screen bg-[rgba(64,63,63,.54)] fixed top-0 left-0`;
const webMainHeading = `text-xl font-medium leading-snug text-black`;
const webMainHeadingMobile = `text-base font-medium leading-snug text-black`;
const webBasetext = `${baseText}`;
const webSubHeading = `text-base font-medium leading-snug text-kyc-primary-dark`;
const webNavItem = `text-sm font-medium leading-snug text-black inline-block`;
const actionItemDefault = `border border-kyc-secondary-grey rounded-3xl flex items-center opacity-70`;
const actionItemBordered = `border border-kyc-primary-dark rounded-3xl flex items-center`;
const BaseStyles = {
  mainHeading,
  pageHeading,
  subHeading,
  contentHeading,
  baseText,
  navMenuHeading,
  navMenuDesctiption,
  baseDescription,
  actionBtnAccent,
  baseLabel,
  baseInput,
  tableCaption,
  tableValue,
  modalBottomOverlay,
  actionBtnDisabled,
  nativeSelect,
  webMainHeading,
  webBasetext,
  webSubHeading,
  webNavItem,
  webMainHeadingMobile,
  actionItemBordered,
  actionItemDefault
};
const DappHeader = ({ providerInfo = "", headerTitle = "", classes = "", description = "", smallHeading = false }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: classes, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center max-w-[66px] mb-2.5 relative m-auto items-center -left-3.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { className: "", name: "swtr-logo", color: "", size: "36px" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { className: "absolute left-1/2", name: "swtr-example-service", size: "48", color: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${BaseStyles.baseDescription} text-center mb-6 !text-sm`, children: providerInfo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: `${!smallHeading ? BaseStyles.webMainHeading : BaseStyles.webMainHeadingMobile} text-center mb-2`, children: headerTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${BaseStyles.webBasetext} text-center`, children: description })
  ] });
};
const RaysPreloader = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "45", height: "45", viewBox: "0 0 45 45", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23.8125 1.5V8.5C23.8125 8.8481 23.6742 9.18194 23.4281 9.42808C23.1819 9.67422 22.8481 9.8125 22.5 9.8125C22.1519 9.8125 21.8181 9.67422 21.5719 9.42808C21.3258 9.18194 21.1875 8.8481 21.1875 8.5V1.5C21.1875 1.1519 21.3258 0.818064 21.5719 0.571922C21.8181 0.325781 22.1519 0.1875 22.5 0.1875C22.8481 0.1875 23.1819 0.325781 23.4281 0.571922C23.6742 0.818064 23.8125 1.1519 23.8125 1.5ZM32.3984 13.9141C32.571 13.9145 32.7419 13.8809 32.9014 13.8152C33.0609 13.7495 33.2059 13.653 33.3281 13.5312L38.2762 8.58094C38.5081 8.33213 38.6343 8.00305 38.6283 7.66302C38.6223 7.323 38.4846 6.99857 38.2441 6.7581C38.0036 6.51763 37.6792 6.37988 37.3392 6.37388C36.9991 6.36788 36.6701 6.4941 36.4212 6.72594L31.4688 11.6719C31.2847 11.8553 31.1592 12.0893 31.1082 12.3441C31.0572 12.5989 31.083 12.8631 31.1824 13.1033C31.2817 13.3434 31.4501 13.5486 31.6662 13.693C31.8823 13.8373 32.1364 13.9143 32.3963 13.9141H32.3984ZM43.5 21.1875H36.5C36.1519 21.1875 35.8181 21.3258 35.5719 21.5719C35.3258 21.8181 35.1875 22.1519 35.1875 22.5C35.1875 22.8481 35.3258 23.1819 35.5719 23.4281C35.8181 23.6742 36.1519 23.8125 36.5 23.8125H43.5C43.8481 23.8125 44.1819 23.6742 44.4281 23.4281C44.6742 23.1819 44.8125 22.8481 44.8125 22.5C44.8125 22.1519 44.6742 21.8181 44.4281 21.5719C44.1819 21.3258 43.8481 21.1875 43.5 21.1875ZM33.3281 31.4688C33.0816 31.2222 32.7471 31.0837 32.3984 31.0837C32.0497 31.0837 31.7153 31.2222 31.4688 31.4688C31.2222 31.7153 31.0837 32.0497 31.0837 32.3984C31.0837 32.7471 31.2222 33.0816 31.4688 33.3281L36.4191 38.2762C36.6679 38.5081 36.997 38.6343 37.337 38.6283C37.677 38.6223 38.0014 38.4846 38.2419 38.2441C38.4824 38.0036 38.6201 37.6792 38.6261 37.3392C38.6321 36.9991 38.5059 36.6701 38.2741 36.4212L33.3281 31.4688ZM22.5 35.1875C22.1519 35.1875 21.8181 35.3258 21.5719 35.5719C21.3258 35.8181 21.1875 36.1519 21.1875 36.5V43.5C21.1875 43.8481 21.3258 44.1819 21.5719 44.4281C21.8181 44.6742 22.1519 44.8125 22.5 44.8125C22.8481 44.8125 23.1819 44.6742 23.4281 44.4281C23.6742 44.1819 23.8125 43.8481 23.8125 43.5V36.5C23.8125 36.1519 23.6742 35.8181 23.4281 35.5719C23.1819 35.3258 22.8481 35.1875 22.5 35.1875ZM11.6719 31.4688L6.72375 36.4212C6.5948 36.5414 6.49137 36.6863 6.41963 36.8473C6.3479 37.0083 6.30932 37.1821 6.30621 37.3583C6.30311 37.5346 6.33552 37.7096 6.40154 37.873C6.46755 38.0365 6.5658 38.1849 6.69043 38.3096C6.81507 38.4342 6.96353 38.5325 7.12695 38.5985C7.29038 38.6645 7.46543 38.6969 7.64166 38.6938C7.81789 38.6907 7.99169 38.6521 8.15269 38.5804C8.31369 38.5086 8.45859 38.4052 8.57875 38.2762L13.5312 33.3281C13.6533 33.206 13.7502 33.0611 13.8163 32.9016C13.8823 32.7421 13.9163 32.5711 13.9163 32.3984C13.9163 32.2258 13.8823 32.0548 13.8163 31.8953C13.7502 31.7358 13.6533 31.5908 13.5312 31.4688C13.4092 31.3467 13.2642 31.2498 13.1047 31.1837C12.9452 31.1177 12.7742 31.0837 12.6016 31.0837C12.4289 31.0837 12.2579 31.1177 12.0984 31.1837C11.9389 31.2498 11.794 31.3467 11.6719 31.4688ZM9.8125 22.5C9.8125 22.1519 9.67422 21.8181 9.42808 21.5719C9.18194 21.3258 8.8481 21.1875 8.5 21.1875H1.5C1.1519 21.1875 0.818064 21.3258 0.571922 21.5719C0.325781 21.8181 0.1875 22.1519 0.1875 22.5C0.1875 22.8481 0.325781 23.1819 0.571922 23.4281C0.818064 23.6742 1.1519 23.8125 1.5 23.8125H8.5C8.8481 23.8125 9.18194 23.6742 9.42808 23.4281C9.67422 23.1819 9.8125 22.8481 9.8125 22.5ZM8.57875 6.72375C8.32994 6.49191 8.00086 6.36569 7.66084 6.37169C7.32081 6.37769 6.99639 6.51544 6.75591 6.75591C6.51544 6.99639 6.37769 7.32081 6.37169 7.66084C6.36569 8.00086 6.49191 8.32994 6.72375 8.57875L11.6719 13.5312C11.9184 13.7778 12.2529 13.9163 12.6016 13.9163C12.9503 13.9163 13.2847 13.7778 13.5312 13.5312C13.7778 13.2847 13.9163 12.9503 13.9163 12.6016C13.9163 12.2529 13.7778 11.9184 13.5312 11.6719L8.57875 6.72375Z", fill: "#0D0C0C" }) });
};
const MontainsShaped = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "393", height: "148", viewBox: "0 0 393 148", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M-101 69.5132L-96.8841 74.0808L-88.8789 83.6303L-83.6256 81.1328L-79.8731 82.3816L-77.8719 81.8821L-72.1181 82.3816L-66.1143 79.8841H-60.8609M-60.8609 79.8841L-54.6069 73.6403L-47.6024 64.6493L-40.3477 59.4045M-60.8609 79.8841L-79.8731 93.8701L-91.6865 98.8761M-40.3477 59.4045L-32.5927 54.909L-28.8403 58.6552L-27.0892 57.4065L-21.5856 62.1517L-13.5805 67.896L-3.07376 77.1368M-40.3477 59.4045L-50.104 77.1368L-55.8577 96.6174H-60.8609M-3.07376 77.1368L3.68059 77.6363L10.4349 73.6403L15.9385 68.6453M-3.07376 77.1368L-11.8294 102.362M15.9385 68.6453L18.6902 66.897L23.1931 62.6512L29.197 63.4005L41.4549 56.4075L45.7076 55.908L51.4613 51.6622L59.2163 58.6552L63.9694 59.1547L67.972 61.902M15.9385 68.6453L20.9417 77.6363L10.4349 94.8691M67.972 61.902L76.4774 50.6632L84.4826 41.9219L92.4878 31.4324L97.491 22.6911L101.994 17.1965M67.972 61.902L58.2157 77.6363L43.4562 78.3856L10.4349 94.8691M101.994 17.1965L103.995 17.696L105.496 20.1936H106.997L110.249 25.4383M101.994 17.1965L103.995 31.4324L98.9919 53.6602M110.249 25.4383L113.251 24.1896L116.003 22.6911M110.249 25.4383L112.501 40.1736L137.767 72.6413L119.755 41.9219L117.754 33.4304L116.003 22.6911M116.003 22.6911L118.254 23.1906L120.756 28.9348L122.757 29.6841L125.759 35.1786L131.013 45.1687L140.018 56.4075L147.273 61.4025L152.276 68.3955L161.532 75.8881L168.537 66.897L172.039 63.6503M172.039 63.6503L182.296 60.903L194.804 74.1398L200.557 70.3935L203.309 71.1428L206.311 70.3935L210.564 71.892L213.816 70.3935L223.081 56.4075L234.652 47.8328M172.039 63.6503L169.68 78.3856M192.302 102.362L202.308 95.3686L222.093 86.8771M192.302 102.362L173.04 93.8701M192.302 102.362L169.68 78.3856M192.302 102.362L164.342 105.858M173.04 93.8701L169.68 78.3856M173.04 93.8701L165.285 91.8721L152.276 81.8821L149.274 81.1328L144.021 82.8811L127.51 75.8881M127.51 75.8881L123.007 71.1428L118.254 72.6413M127.51 75.8881L119.755 83.6303L117.754 88.1259L108.248 93.8701H99.9926M118.254 72.6413L108.248 66.897L98.9919 53.6602M118.254 72.6413L110.249 83.6303L99.9926 89.1249H86.9842M98.9919 53.6602L88.235 63.4005L84.4826 75.8881L71.7244 84.3796M99.9926 93.8701L103.995 99.8642L110.249 98.8652L118.755 101.862L131.763 96.6174L147.273 102.362L164.342 105.858M99.9926 93.8701L86.9842 89.1249M164.342 105.858L172.039 119.867L194.804 115.022L205.269 101.862L223.081 108.963L233.094 102.362M86.9842 89.1249L80.9804 91.1229L71.7244 84.3796M86.9842 89.1249L67.972 111.852L45.7076 123.091L24.7348 142.639L-17.3253 147L-42.3995 139.575M71.7244 84.3796L48.7096 96.6174L29.9114 100.487L22.3082 96.6174L12.1167 100.487L-11.8294 102.362M10.4349 94.8691L-11.8294 102.362M-11.8294 102.362L-42.3995 103.581L-60.8609 96.6174M-60.8609 96.6174L-64.8635 111.852L-55.8577 125.197L-42.3995 139.575M-60.8609 96.6174L-79.8731 104.609L-96.8841 125.197M-96.8841 125.197L-101 102.791L-91.6865 98.8761M-96.8841 125.197L-81.2242 143.608M-81.2242 143.608L-42.3995 139.575M-81.2242 143.608L-101 139.005M234.652 47.8328L240.185 61.4025M234.652 47.8328L238.676 45.1687L241.191 43.0616L249.492 41.9219M240.185 61.4025L238.676 72.6413L248.624 82.8811M240.185 61.4025L249.492 41.9219M248.624 82.8811L283.7 88.1259L293.006 87.7096M248.624 82.8811L222.093 86.8771M311.62 86.8771C314.47 82.6313 320.373 74.1398 321.178 74.1398C321.83 74.1398 327.6 70.9646 331.993 68.4764M311.62 86.8771L288.742 77.2301M311.62 86.8771L328.22 102.362M311.62 86.8771L293.006 87.7096M262.823 55.1152L278.921 74.1398L288.742 77.2301M262.823 55.1152L258.295 50.5951M262.823 55.1152L277.742 46.075L285.992 40.2456L298.449 27.4867L306.589 22.3186M258.295 50.5951L253.768 47.8328L249.492 41.9219M258.295 50.5951L262.823 64.9088L270.117 75.8881L293.006 87.7096M399.716 1L390.981 9.07522L379.819 28.4558L372.539 32.6549L362.906 44.0661M399.716 1L396.481 13.2743L398.26 27.4867L405.943 51.5996L402.422 61.4025M399.716 1L402.207 5.00114M402.422 61.4025L410.973 80.2269L429.838 88.1259L474.107 106.607L499.26 99.5177L530.953 95.3686L541.588 91.604M402.422 61.4025L388.587 86.8771L349.852 108.963M550 102.827L541.588 91.604M306.589 22.3186L305.89 27.4867L307.074 33.7703L310.596 26.1865M306.589 22.3186L310.596 26.1865M314.14 26.1865L312.105 24.2278L310.596 26.1865M314.14 26.1865L311.62 56.4075L306.589 64.9088L288.742 77.2301M314.14 26.1865L319.902 33.7703L325.939 32.2636L330.317 29.5013M330.317 29.5013L334.038 32.2636L341.551 41.9219L349.852 46.075L357.649 43.0616L362.906 44.0661M330.317 29.5013L334.76 47.3306L331.993 68.4764M362.906 44.0661L358.655 49.5906L348.343 53.8596L334.76 66.897C333.968 67.3535 333.018 67.8963 331.993 68.4764M475.616 55.1152L488.696 44.0661L490.457 35.0258M475.616 55.1152L456.249 51.4126M475.616 55.1152L495.487 62.424M475.616 55.1152L494.19 73.1925L490.457 75.8881L449.96 75.4557M490.457 35.0258L494.733 28.7479L493.475 20.2099M490.457 35.0258L499.26 46.075L502.279 55.1152L495.487 62.424M493.475 20.2099L478.635 33.7703L456.249 51.4126M493.475 20.2099L501.524 27.2412H505.548M456.249 51.4126L451.973 50.5951L440.905 40.5504L432.857 37.7881L428.329 33.7703H422.292L415.246 19.0885L408.775 7.62168L402.422 5.39404L402.207 5.00114M505.548 27.2412L512.34 35.7792L520.389 47.3306L527.934 49.0884L530.953 54.3619H533.72L550 69.5132L534.474 75.4557M505.548 27.2412L506.806 38.0392L517.873 52.3529L534.474 75.4557M495.487 62.424L504.291 65.6621L525.419 75.4557H534.474M402.207 5.00114L410.973 31.008L422.292 51.5996L449.96 75.4557M449.96 75.4557L488.696 89.2671L509.824 90.5227L530.198 86.8771L546.205 80.769M328.22 102.362L309.356 103.581L284.86 104.201L275.154 98.8717L267.065 101.294L249.492 98.8717L233.094 102.362M328.22 102.362L349.852 108.963M550 138.925L504.291 145.223L464.586 135.21L451.973 115.598H428.329L401.172 95.3686L349.852 108.963M233.094 102.362V92.7345L222.093 86.8771M541.588 91.604C542.406 89.7345 545.007 83.6017 546.205 80.769M-101 82.3816L-95.7714 93.3297L-93.729 96.1029L-91.6865 98.8761M546.205 80.769L550 82.4003", stroke: "#CFCFCF" }) });
};
function InfoBlock({ warnMessage = "" }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: `${BaseStyles.actionItemBordered} info_block p-4`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { name: "attentionMark", color: "", size: "20", className: "mr-9" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: warnMessage })
  ] });
}
var bn$1 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn$1.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w2;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
          w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number2.length; i += 3) {
          w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index2) {
      var c = string.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string);
      }
    }
    function parseHexByte2(string, lowerBound, index2) {
      var r2 = parseHex4Bits(string, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w2;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w2 = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w2 = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul3) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul3;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul3, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number2, i, number2.length, base2);
        for (i = 0; i < mod; i++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
      } catch (e2) {
        BN2.prototype.inspect = inspect4;
      }
    } else {
      BN2.prototype.inspect = inspect4;
    }
    function inspect4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString3(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = this.words[i];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base2);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add3(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul3(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w2 = (this.words[i] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w2.length; i++, res = res.sqr()) {
        if (w2[i] !== 0)
          break;
      }
      if (++i < w2.length) {
        for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
          if (w2[i] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul3;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w2 & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w2 = -(this.words[i] | 0) + carry;
        carry = w2 >> 26;
        this.words[i] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m2 = a.length - b.length;
      var q2;
      if (mode !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i = 0; i < q2.length; i++) {
          q2.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m2);
      if (diff.negative === 0) {
        a = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j = m2 - 1; j >= 0; j--) {
        var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj2, j);
        while (a.negative !== 0) {
          qj2--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p2 * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w2 = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x = this;
      var y2 = p2.clone();
      if (x.negative !== 0) {
        x = x.umod(p2);
      } else {
        x = x.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g = 0;
      while (x.isEven() && y2.isEven()) {
        x.iushrn(1);
        y2.iushrn(1);
        ++g;
      }
      var yp = y2.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y2.iushrn(j);
          while (j-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y2) >= 0) {
          x.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a = this;
      var b = p2.clone();
      if (a.negative !== 0) {
        a = a.umod(p2);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t2 = a;
          a = b;
          b = t2;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w2 = this.words[i] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i] = w2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w2 = num.words[i] | 0;
        lo += w2 * 977;
        num.words[i] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi2 = (num.words[i] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg3(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add3(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul3(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q2);
      var r2 = this.pow(a, q2.addn(1).iushrn(1));
      var t2 = this.pow(a, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m2);
        var b = this.pow(c, new BN2(1).iushln(m2 - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t2 = t2.redMul(c);
        m2 = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t2 = a.imul(b);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul3(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a.mul(b);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports;
const _BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports$1);
const version$g = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i = 0; i < value.length; i++) {
            hex2 += HEX[value[i] >> 4];
            hex2 += HEX[value[i] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$g);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$f = "bytes/5.7.0";
const logger$n = new Logger(version$f);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes$2(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v2 = value[i];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$n.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$n.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex2.length; i += 2) {
      result.push(parseInt(hex2.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$2(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$n.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$n.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$n.checkSafeUint53(value, "invalid hexlify value");
    let hex2 = "";
    while (value) {
      hex2 = HexCharacters[value & 15] + hex2;
      value = Math.floor(value / 16);
    }
    if (hex2.length) {
      if (hex2.length % 2) {
        hex2 = "0" + hex2;
      }
      return "0x" + hex2;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$n.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes$2(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v2 = value[i];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$n.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger$n.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$n.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$n.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$n.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes2 = arrayify(signature2);
    if (bytes2.length === 64) {
      result.v = 27 + (bytes2[32] >> 7);
      bytes2[32] &= 127;
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
    } else if (bytes2.length === 65) {
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
      result.v = bytes2[64];
    } else {
      logger$n.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$n.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes2[32] |= 128;
    }
    result._vs = hexlify(bytes2.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$n.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$n.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$n.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$n.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$n.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$n.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$n.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$n.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$n.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
const version$e = "bignumber/5.7.0";
var BN$1 = _BN.BN;
const logger$m = new Logger(version$e);
const _constructorGuard$2 = {};
const MAX_SAFE = 9007199254740991;
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex2) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$m.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex2;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$m.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$m.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$m.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$m.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$2, toHex$1(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$2, toHex$1(new BN$1(value)));
      }
      return logger$m.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes$2(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex2 = anyValue.toHexString();
        if (typeof hex2 === "string") {
          return BigNumber.from(hex2);
        }
      } else {
        let hex2 = anyValue._hex;
        if (hex2 == null && anyValue.type === "BigNumber") {
          hex2 = anyValue.hex;
        }
        if (typeof hex2 === "string") {
          if (isHexString(hex2) || hex2[0] === "-" && isHexString(hex2.substring(1))) {
            return BigNumber.from(hex2);
          }
        }
      }
    }
    return logger$m.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$1(value) {
  if (typeof value !== "string") {
    return toHex$1(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$m.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$1(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$1(value));
}
function toBN(value) {
  const hex2 = BigNumber.from(value).toHexString();
  if (hex2[0] === "-") {
    return new BN$1("-" + hex2.substring(3), 16);
  }
  return new BN$1(hex2.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$m.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$1(value, 36).toString(16);
}
const version$d = "properties/5.7.0";
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger(version$d);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$l.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger$l.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$l.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$l.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const version$c = "abi/5.7.0";
const logger$k = new Logger(version$c);
const _constructorGuard$1 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger$k.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger$k.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger$k.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$k.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$1, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$k.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$k.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$k.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$k.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$k.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$k.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$k.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$k.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$k.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$k.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$k.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$k.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$k.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$k.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$k.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger$k.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$k.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output2) => JSON.parse(output2.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output2) => output2.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$k.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$k.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$k.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$k.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$k.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$k.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$k.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$k.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger$k.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$j = new Logger(version$c);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$j.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes2 = arrayify(value);
    const paddingOffset = bytes2.length % this.wordSize;
    if (paddingOffset) {
      bytes2 = concat([bytes2, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes2);
  }
  _getValue(value) {
    let bytes2 = arrayify(BigNumber.from(value));
    if (bytes2.length > this.wordSize) {
      logger$j.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes2.length
      });
    }
    if (bytes2.length % this.wordSize) {
      bytes2 = concat([this._padding.slice(bytes2.length % this.wordSize), bytes2]);
    }
    return bytes2;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name, value) {
    let match = name.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }
    return Reader.coerce(name, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$j.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes2 = this._peekBytes(0, length, !!loose);
    this._offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0; i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i2, code;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            blocks[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            code = message.charCodeAt(index2);
            if (code < 128) {
              blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
            } else if (code < 2048) {
              blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks[blockCount];
          for (i2 = 0; i2 < blockCount; ++i2) {
            s2[i2] ^= blocks[i2];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x, right) {
      var o = x & 255, n2 = 1;
      var bytes2 = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes2.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n2;
      }
      if (right) {
        bytes2.push(n2);
      } else {
        bytes2.unshift(n2);
      }
      this.update(bytes2);
      return bytes2.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes2 = 0, length = str.length;
      if (notString) {
        bytes2 = length;
      } else {
        for (var i2 = 0; i2 < str.length; ++i2) {
          var code = str.charCodeAt(i2);
          if (code < 128) {
            bytes2 += 1;
          } else if (code < 2048) {
            bytes2 += 2;
          } else if (code < 55296 || code >= 57344) {
            bytes2 += 3;
          } else {
            code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes2 += 4;
          }
        }
      }
      bytes2 += this.encode(bytes2 * 8);
      this.update(str);
      return bytes2;
    };
    Keccak.prototype.bytepad = function(strs, w2) {
      var bytes2 = this.encode(w2);
      for (var i2 = 0; i2 < strs.length; ++i2) {
        bytes2 += this.encodeString(strs[i2]);
      }
      var paddingBytes = w2 - bytes2 % w2;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i2 = 1; i2 < blockCount + 1; ++i2) {
          blocks[i2] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i2 = 0; i2 < blockCount; ++i2) {
        s2[i2] ^= blocks[i2];
      }
      f2(s2);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var hex2 = "", block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          block = s2[i2];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i2];
        hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var bytes2 = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes2);
      }
      var array = new Uint32Array(buffer);
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          array[j2] = s2[i2];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i2] = s2[i2];
        buffer = buffer.slice(0, bytes2);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var array = [], offset, block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          offset = j2 << 2;
          block = s2[i2];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j2 << 2;
        block = s2[i2];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports);
function keccak256(data) {
  return "0x" + sha3.keccak_256(arrayify(data));
}
const version$b = "rlp/5.7.0";
const logger$i = new Logger(version$b);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$i.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode$5(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode$1(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger$i.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode$1(data, offset) {
  if (data.length === 0) {
    logger$i.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger$i.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$i.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger$i.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger$i.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$i.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger$i.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode$3(data) {
  const bytes2 = arrayify(data);
  const decoded = _decode$1(bytes2, 0);
  if (decoded.consumed !== bytes2.length) {
    logger$i.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
const version$a = "address/5.7.0";
const logger$h = new Logger(version$a);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$h.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$h.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$h.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$h.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$h.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress(transaction) {
  let from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger$h.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode$5([from, nonce])), 12));
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$g = new Logger(version$c);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger$g.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger$g.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger$g.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$g.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger$g.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger$g.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v2 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}
const version$9 = "strings/5.7.0";
const logger$f = new Logger(version$9);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  return logger$f.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes2, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes2 = arrayify(bytes2);
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c = bytes2[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes2, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes2, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$f.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$e = new Logger(version$c);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger$e.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger$e.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger$e.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger$e.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
const version$8 = "hash/5.7.0";
function decode$2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify(data);
}
function encode$4(data) {
  data = arrayify(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach2 = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach2.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(bytes2) {
  return read_payload(decode_arithmetic(bytes2));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n2, next) {
  let v2 = Array(n2);
  for (let i = 0; i < n2; i++)
    v2[i] = 1 + next();
  return v2;
}
function read_ascending(n2, next) {
  let v2 = Array(n2);
  for (let i = 0, x = -1; i < n2; i++)
    v2[i] = x += 1 + next();
  return v2;
}
function read_deltas(n2, next) {
  let v2 = Array(n2);
  for (let i = 0, x = 0; i < n2; i++)
    v2[i] = x += signed(next());
  return v2;
}
function read_member_array(next, lookup) {
  let v2 = read_ascending(next(), next);
  let n2 = next();
  let vX = read_ascending(n2, next);
  let vN = read_counts(n2, next);
  for (let i = 0; i < n2; i++) {
    for (let j = 0; j < vN[i]; j++) {
      v2.push(vX[i] + j);
    }
  }
  return lookup ? v2.map((x) => lookup[x]) : v2;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v2 = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v2.push(i);
  }
  return v2;
}
function read_transposed(n2, w2, next) {
  let m2 = Array(n2).fill(void 0).map(() => []);
  for (let i = 0; i < w2; i++) {
    read_deltas(n2, next).forEach((x, j) => m2[j].push(x));
  }
  return m2;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return flat(m2.map((v2, i) => {
    const x = v2[0], ys = v2.slice(1);
    return Array(vN[i]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m2 = read_transposed(n2, 1 + w2, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a, b) => a - b);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read() });
    }
    branches.sort((a, b) => b.set.size - a.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
function getData() {
  return read_compressed_payload(decode$2("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"));
}
const r$1 = getData();
const VALID = new Set(read_member_array(r$1));
const IGNORED = new Set(read_member_array(r$1));
const MAPPED = read_mapped_map(r$1);
const EMOJI_ROOT = read_emoji_trie(r$1);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name) {
  return toUtf8CodePoints(name);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name) {
  for (let label of name.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name;
}
function ens_normalize(name) {
  return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
  let input = explode_cp(name).reverse();
  let output2 = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output2.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output2.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output2.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output2)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = (_a = node.branches.find((x) => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$d = new Logger(version$8);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ens_normalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d2 = bytes2[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  if (last >= bytes2.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function namehash(name) {
  if (typeof name !== "string") {
    logger$d.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$c = new Logger(version$8);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = arrayify(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return hexConcat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$c.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$c.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$c.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes2 = arrayify(value);
      if (bytes2.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes2);
    } catch (error) {
    }
    return logger$c.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$c.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$c.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$c.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes2 = arrayify(value);
        if (bytes2.length !== width) {
          logger$c.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
class TypedDataEncoder {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name in types) {
      const uniqueNames = {};
      types[name].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$c.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name) {
          logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          return;
        }
        if (!parents[baseType]) {
          logger$c.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name);
        links[name][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$c.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger$c.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name in subtypes) {
      const st = Object.keys(subtypes[name]);
      st.sort();
      this._types[name] = encodeType(name, types[name]) + st.map((t2) => encodeType(t2, types[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder2 = this._encoderCache[type];
    if (!encoder2) {
      encoder2 = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder2;
  }
  _getEncoder(type) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return encoder2;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this._types[type2]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$c.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name) {
    const result = this._types[name];
    if (!result) {
      logger$c.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    return logger$c.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      const type = domainFieldTypes[name];
      if (!type) {
        logger$c.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      }
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak256(TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter$7(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder2 = TypedDataEncoder.from(types);
      encoder2.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name in ensCache) {
        ensCache[name] = yield resolveName2(name);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder2.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder2 = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger$c.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$c.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$c.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const logger$b = new Logger(version$c);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
class Interface {
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$b.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$b.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$b.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi2.map((j) => JSON.parse(j)));
    }
    return abi2;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name)) {
          return this.functions[name];
        }
      }
      logger$b.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name);
      if (matching.length === 0) {
        logger$b.throwArgumentError("no matching function", "name", name);
      } else if (matching.length > 1) {
        logger$b.throwArgumentError("multiple matching functions", "name", name);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$b.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name in this.events) {
        if (topichash === this.getEventTopic(name)) {
          return this.events[name];
        }
      }
      logger$b.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name);
      if (matching.length === 0) {
        logger$b.throwArgumentError("no matching event", "name", name);
      } else if (matching.length > 1) {
        logger$b.throwArgumentError("multiple matching events", "name", name);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$b.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name in this.errors) {
        const error = this.errors[name];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name];
        }
      }
      logger$b.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name);
      if (matching.length === 0) {
        logger$b.throwArgumentError("no matching error", "name", name);
      } else if (matching.length > 1) {
        logger$b.throwArgumentError("multiple matching errors", "name", name);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$b.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes2 = arrayify(data);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$b.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(fragment.inputs, bytes2.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes2 = arrayify(data);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$b.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(functionFragment.inputs, bytes2.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes2 = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes2.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes2);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes2.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes2.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes2.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$b.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$b.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$b.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$b.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$b.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$b.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const version$7 = "abstract-provider/5.7.0";
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$7);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$a.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$6 = "abstract-signer/5.7.0";
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$6);
const allowedTransactionKeys$1 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$9.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$1.indexOf(key2) === -1) {
        logger$9.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$9.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$5(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$9.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$9.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$9.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$9.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$9.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$9.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$9.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$9.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}
var bn = { exports: {} };
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w2;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
          w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number2.length; i += 3) {
          w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index2) {
      var c = string.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string);
      }
    }
    function parseHexByte2(string, lowerBound, index2) {
      var r2 = parseHex4Bits(string, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w2;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w2 = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w2 = parseHexByte2(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul3) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul3;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul3, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number2, i, number2.length, base2);
        for (i = 0; i < mod; i++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
      } catch (e2) {
        BN2.prototype.inspect = inspect4;
      }
    } else {
      BN2.prototype.inspect = inspect4;
    }
    function inspect4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString3(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = this.words[i];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base2);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add3(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul3(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w2 = (this.words[i] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w2.length; i++, res = res.sqr()) {
        if (w2[i] !== 0)
          break;
      }
      if (++i < w2.length) {
        for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
          if (w2[i] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul3;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w2 & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w2 = -(this.words[i] | 0) + carry;
        carry = w2 >> 26;
        this.words[i] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m2 = a.length - b.length;
      var q2;
      if (mode !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i = 0; i < q2.length; i++) {
          q2.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m2);
      if (diff.negative === 0) {
        a = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j = m2 - 1; j >= 0; j--) {
        var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj2, j);
        while (a.negative !== 0) {
          qj2--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p2 * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w2 = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x = this;
      var y2 = p2.clone();
      if (x.negative !== 0) {
        x = x.umod(p2);
      } else {
        x = x.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g = 0;
      while (x.isEven() && y2.isEven()) {
        x.iushrn(1);
        y2.iushrn(1);
        ++g;
      }
      var yp = y2.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y2.iushrn(j);
          while (j-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y2) >= 0) {
          x.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a = this;
      var b = p2.clone();
      if (a.negative !== 0) {
        a = a.umod(p2);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t2 = a;
          a = b;
          b = t2;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w2 = this.words[i] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i] = w2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w2 = num.words[i] | 0;
        lo += w2 * 977;
        num.words[i] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi2 = (num.words[i] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg3(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add3(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul3(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q2);
      var r2 = this.pow(a, q2.addn(1).iushrn(1));
      var t2 = this.pow(a, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m2);
        var b = this.pow(c, new BN2(1).iushln(m2 - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t2 = t2.redMul(c);
        m2 = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t2 = a.imul(b);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul3(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a.mul(b);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
var hash$2 = {};
var utils$b = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser$1.exports;
var assert$a = minimalisticAssert$1;
var inherits$1 = inherits_browserExports;
utils$b.inherits = inherits$1;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p2++] = c;
        } else if (c < 2048) {
          res[p2++] = c >> 6 | 192;
          res[p2++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p2++] = c >> 18 | 240;
          res[p2++] = c >> 12 & 63 | 128;
          res[p2++] = c >> 6 & 63 | 128;
          res[p2++] = c & 63 | 128;
        } else {
          res[p2++] = c >> 12 | 224;
          res[p2++] = c >> 6 & 63 | 128;
          res[p2++] = c & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$b.toArray = toArray$1;
function toHex(msg) {
  var res = "";
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$b.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$b.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i = 0; i < msg.length; i++) {
    var w2 = msg[i];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$b.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$b.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$b.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k2 = start; i < res.length; i++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i] = w2 >>> 0;
  }
  return res;
}
utils$b.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k2 = 0; i < msg.length; i++, k2 += 4) {
    var m2 = msg[i];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$b.split32 = split32;
function rotr32$1(w2, b) {
  return w2 >>> b | w2 << 32 - b;
}
utils$b.rotr32 = rotr32$1;
function rotl32$2(w2, b) {
  return w2 << b | w2 >>> 32 - b;
}
utils$b.rotl32 = rotl32$2;
function sum32$3(a, b) {
  return a + b >>> 0;
}
utils$b.sum32 = sum32$3;
function sum32_3$1(a, b, c) {
  return a + b + c >>> 0;
}
utils$b.sum32_3 = sum32_3$1;
function sum32_4$2(a, b, c, d2) {
  return a + b + c + d2 >>> 0;
}
utils$b.sum32_4 = sum32_4$2;
function sum32_5$2(a, b, c, d2, e2) {
  return a + b + c + d2 + e2 >>> 0;
}
utils$b.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo;
}
utils$b.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$b.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
utils$b.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$b.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
utils$b.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$b.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
utils$b.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$b.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$b.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$b.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$b.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$a = utils$b;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$a.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$a.join32(msg, 0, msg.length - r2, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes2 = this._delta8;
  var k2 = bytes2 - (len + this.padLength) % bytes2;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i = 1; i < k2; i++)
    res[i] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len & 255;
  } else {
    res[i++] = len & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 24 & 255;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$9 = utils$b;
var rotr32 = utils$9.rotr32;
function ft_1$1(s2, x, y2, z) {
  if (s2 === 0)
    return ch32$1(x, y2, z);
  if (s2 === 1 || s2 === 3)
    return p32(x, y2, z);
  if (s2 === 2)
    return maj32$1(x, y2, z);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y2, z) {
  return x & y2 ^ ~x & z;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y2, z) {
  return x & y2 ^ x & z ^ y2 & z;
}
common$4.maj32 = maj32$1;
function p32(x, y2, z) {
  return x ^ y2 ^ z;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$8 = utils$b;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$8.rotl32;
var sum32$2 = utils$8.sum32;
var sum32_5$1 = utils$8.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$8.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = rotl32$1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i = 0; i < W2.length; i++) {
    var s2 = ~~(i / 20);
    var t2 = sum32_5$1(rotl32$1(a, 5), ft_1(s2, b, c, d2), e2, W2[i], sha1_K[s2]);
    e2 = d2;
    d2 = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t2;
  }
  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h, "big");
  else
    return utils$8.split32(this.h, "big");
};
var utils$7 = utils$b;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$7.sum32;
var sum32_4$1 = utils$7.sum32_4;
var sum32_5 = utils$7.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$7.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = sum32_4$1(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g = this.h[6];
  var h2 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i = 0; i < W2.length; i++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g), this.k[i], W2[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h2 = g;
    g = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$2.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h, "big");
  else
    return utils$7.split32(this.h, "big");
};
var utils$6 = utils$b;
var SHA256$1 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$1.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$6.inherits(SHA224, SHA256$1);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$6.split32(this.h.slice(0, 7), "big");
};
var utils$5 = utils$b;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$5.rotr64_hi;
var rotr64_lo = utils$5.rotr64_lo;
var shr64_hi = utils$5.shr64_hi;
var shr64_lo = utils$5.shr64_lo;
var sum64 = utils$5.sum64;
var sum64_hi = utils$5.sum64_hi;
var sum64_lo = utils$5.sum64_lo;
var sum64_4_hi = utils$5.sum64_4_hi;
var sum64_4_lo = utils$5.sum64_4_lo;
var sum64_5_hi = utils$5.sum64_5_hi;
var sum64_5_lo = utils$5.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$5.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 32; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i += 2) {
    var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
    var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
    var c1_hi = W2[i - 14];
    var c1_lo = W2[i - 13];
    var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
    var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
    var c3_hi = W2[i - 32];
    var c3_lo = W2[i - 31];
    W2[i] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i = 0; i < W2.length; i += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W2[i];
    var c4_lo = W2[i + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "big");
  else
    return utils$5.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$4 = utils$b;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$4.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$4.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$3 = utils$b;
var common = common$5;
var rotl32 = utils$3.rotl32;
var sum32 = utils$3.sum32;
var sum32_3 = utils$3.sum32_3;
var sum32_4 = utils$3.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$3.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j = 0; j < 80; j++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f(j, B2, C2, D2), msg[r[j] + start], K(j)),
        s[j]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f(79 - j, Bh2, Ch2, Dh2), msg[rh[j] + start], Kh(j)),
        sh[j]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$3.toHex32(this.h, "little");
  else
    return utils$3.split32(this.h, "little");
};
function f(j, x, y2, z) {
  if (j <= 15)
    return x ^ y2 ^ z;
  else if (j <= 31)
    return x & y2 | ~x & z;
  else if (j <= 47)
    return (x | ~y2) ^ z;
  else if (j <= 63)
    return x & z | y2 & ~z;
  else
    return x ^ (y2 | ~z);
}
function K(j) {
  if (j <= 15)
    return 0;
  else if (j <= 31)
    return 1518500249;
  else if (j <= 47)
    return 1859775393;
  else if (j <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j) {
  if (j <= 15)
    return 1352829926;
  else if (j <= 31)
    return 1548603684;
  else if (j <= 47)
    return 1836072691;
  else if (j <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$2 = utils$b;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$2.toArray(key2, enc));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i = key2.length; i < this.blockSize; i++)
    key2.push(0);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$b;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$1;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$2);
const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash$2);
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire$1(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi2 = c >> 8;
        var lo = c & 255;
        if (hi2)
          res.push(hi2, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero22(msg[i].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode3(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name, computer) {
    var key2 = "_" + name;
    obj.prototype[name] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes2) {
    return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes2) {
    return new BN(bytes2, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l2 = j + doubles.step - 1; l2 >= j; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I2; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l2 = 0; i >= 0 && naf[i] === 0; i--)
      l2++;
    if (i >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p2;
  for (i = 0; i < len; i++) {
    p2 = points[i];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b]
      /* 7 */
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja2 = jsf[0][j] | 0;
      var jb2 = jsf[1][j] | 0;
      naf[a][j] = index2[(ja2 + 1) * 3 + (jb2 + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k2 = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i--;
    }
    if (i >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
  bytes2 = utils_1$1.toArray(bytes2, enc);
  var len = this.p.byteLength();
  if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
    if (bytes2[0] === 6)
      assert$1(bytes2[bytes2.length - 1] % 2 === 0);
    else if (bytes2[0] === 7)
      assert$1(bytes2[bytes2.length - 1] % 2 === 1);
    var res = this.point(
      bytes2.slice(1, 1 + len),
      bytes2.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
    return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl3 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i = 0; i < k2; i++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r2;
  var x;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x, y3);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p2 = points[i];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p2;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve, x, y2, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x, y2, isRed) {
  return new Point(this, x, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p2.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k2) {
  k2 = new BN(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x, y2, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x === null && y2 === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y2, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y2, z) {
  return new JPoint(this, x, y2, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i = 0; i < pow; i++)
      r2 = r2.dbl();
    return r2;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d2 = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d2 = d2.redIAdd(d2);
    var e2 = a.redAdd(a).redIAdd(a);
    var f2 = e2.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k2, kbase) {
  k2 = new BN(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc2 = x.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc2.iadd(this.curve.n);
    if (xc2.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$1.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$1.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$1.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p2.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN(r2);
  this.s = new BN(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes2 = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (; ; ) {
    var priv = new BN(drbg.generate(bytes2));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN(msg, 16));
  var bytes2 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes2);
  var nonce = msg.toArray("be", bytes2);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n2 = this.n;
  var e2 = new BN(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;
const version$5 = "signing-key/5.7.0";
const logger$8 = new Logger(version$5);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$8.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$8.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes2 = arrayify(key2);
  if (bytes2.length === 32) {
    const signingKey = new SigningKey(bytes2);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes2).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes2.length === 33) {
    if (compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(false, "hex");
  } else if (bytes2.length === 65) {
    if (!compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(true, "hex");
  }
  return logger$8.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$4 = "transactions/5.7.0";
const logger$7 = new Logger(version$4);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$7.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$7.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger$7.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$7.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$5(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$5(fields)]);
}
function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$7.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256(serialize(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$7.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$7.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$3(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$7.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256(encode$5(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$7.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const version$3 = "contracts/5.7.0";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$6 = new Logger(version$3);
function resolveName(resolver, nameOrPromise) {
  return __awaiter$4(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger$6.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger$6.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger$6.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$4(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$6.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver, v2, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$4(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger$6.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$4(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger$6.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes2 = arrayify(data);
      for (let i = 0; i < bytes2.length; i++) {
        intrinsic += 4;
        if (bytes2[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$6.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger$6.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$6.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$6.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i) => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$6.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag$1(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$6.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name) => {
        const filters = uniqueFilters[name];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name, this.filters[filters[0]]);
        } else {
          logger$6.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$6.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger$6.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$6.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name = fragment.name;
        if (!uniqueNames[`%${name}`]) {
          uniqueNames[`%${name}`] = [];
        }
        uniqueNames[`%${name}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name) => {
      const signatures = uniqueNames[name];
      if (signatures.length > 1) {
        return;
      }
      name = name.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name] == null) {
          defineReadOnly(this, name, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name] == null) {
        defineReadOnly(this.functions, name, this.functions[signature2]);
      }
      if (this.callStatic[name] == null) {
        defineReadOnly(this.callStatic, name, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name] == null) {
        defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name] == null) {
        defineReadOnly(this.estimateGas, name, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger$6.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$6.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger$6.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger$6.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$6.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes2 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes2);
    }
    bytes2.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes2.length; ++j) {
        carry += bytes2[j] * this.base;
        bytes2[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes2.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes2.push(0);
    }
    return arrayify(new Uint8Array(bytes2.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function sha256$1(data) {
  return "0x" + hash$1.sha256().update(arrayify(data)).digest("hex");
}
const version$2 = "networks/5.7.1";
const logger$5 = new Logger(version$2);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks) {
      const standard2 = networks[name];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$5.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$5.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$1 = "web/5.7.1";
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$3(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$4 = new Logger(version$1);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$4.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$4.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$4.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$4.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$4(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$2(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$4.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$2(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$4.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$4.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$4.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$4.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET$1.length; z++) {
  var x = ALPHABET$1.charAt(z);
  if (ALPHABET_MAP[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (i = 0; i < prefix.length; ++i) {
    var v2 = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode$3(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i = 0; i < words.length; ++i) {
    var x = words[i];
    if (x >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x;
    result += ALPHABET$1.charAt(x);
  }
  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i = 0; i < 6; ++i) {
    var v2 = chk >> (5 - i) * 5 & 31;
    result += ALPHABET$1.charAt(v2);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    return chk;
  var words = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v2 = ALPHABET_MAP[c];
    if (v2 === void 0)
      return "Unknown character " + c;
    chk = polymodStep(chk) ^ v2;
    if (i + 6 >= wordChars.length)
      continue;
    words.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$1(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad2) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes2) {
  var res = convert(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes2) {
  var res = convert(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$1,
  encode: encode$3,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs(bech32);
const version = "providers/5.7.2";
const logger$3 = new Logger(version);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex2 = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data,
      logIndex: number2,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex2),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash2),
      parentHash: hash2,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex2),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$3.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$3.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$3.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$2.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$2.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256$1(sha256$1(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$2.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = arrayify(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$2.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$2.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes2 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes2[1];
      let version2 = bytes2[0];
      if (version2 === 0) {
        if (length !== 20 && length !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes2.length === 2 + length && length >= 1 && length <= 75) {
        const words = bech32$1.toWords(bytes2.slice(2));
        words.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$2.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i = 0; i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = encode$4("0x" + skynet[1]).replace(/[=+\/]/g, (a) => urlSafe[a]);
          return "sia://" + hash2;
        }
      }
      return logger$2.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$2.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$2.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$2.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$2.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$2.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return logger$2.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger$2.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$1(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$1(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti2 = 0; ti2 < block.transactions.length; ti2++) {
                    const tx = block.transactions[ti2];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$2.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$2.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$2.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter$1(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$2.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$2.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$2.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger$2.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger$2.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$2.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$1(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$2.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$2.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$2.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$2.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let currentName = name;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name);
          if (currentName !== name && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name, operation) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$2.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name) {
    return __awaiter$1(this, void 0, void 0, function* () {
      name = yield name;
      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        if (isHexString(name)) {
          throw error;
        }
      }
      if (typeof name !== "string") {
        logger$2.throwArgumentError("invalid ENS name", "name", name);
      }
      const resolver = yield this.getResolver(name);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$1(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name);
      if (addr != address) {
        return null;
      }
      return name;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$2.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$1 = new Logger(version);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$1.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$1.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$1.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$1.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$1.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$1.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$1.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$1.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$1.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$1.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$1.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
        return this.provider.resolveName(name);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a) => this.formatter.address(a));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$1.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
const logger = new Logger(version);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes$1(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  if (!isBytes(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
class HMAC extends Hash {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key2 = toBytes$1(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key2.length > blockLen ? hash$12.create().update(key2).digest() : key2);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash$12.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac2 = (hash2, key2, message) => new HMAC(hash2, key2).update(message).digest();
hmac2.create = (hash2, key2) => new HMAC(hash2, key2);
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
const Chi = (a, b, c) => a & b ^ ~a & c;
const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(module) {
  (function(nacl) {
    var gf = function(init3) {
      var i, r2 = new Float64Array(16);
      if (init3)
        for (i = 0; i < init3.length; i++)
          r2[i] = init3[i];
      return r2;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h2, l2) {
      x[i] = h2 >> 24 & 255;
      x[i + 1] = h2 >> 16 & 255;
      x[i + 2] = h2 >> 8 & 255;
      x[i + 3] = h2 & 255;
      x[i + 4] = l2 >> 24 & 255;
      x[i + 5] = l2 >> 16 & 255;
      x[i + 6] = l2 >> 8 & 255;
      x[i + 7] = l2 & 255;
    }
    function vn(x, xi2, y2, yi2, n2) {
      var i, d2 = 0;
      for (i = 0; i < n2; i++)
        d2 |= x[xi2 + i] ^ y2[yi2 + i];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi2, y2, yi2) {
      return vn(x, xi2, y2, yi2, 16);
    }
    function crypto_verify_32(x, xi2, y2, yi2) {
      return vn(x, xi2, y2, yi2, 32);
    }
    function core_salsa20(o, p2, k2, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p2, k2, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c) {
      core_salsa20(out, inp, k2, c);
    }
    function crypto_core_hsalsa20(out, inp, k2, c) {
      core_hsalsa20(out, inp, k2, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b, n2, k2) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n2[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = m2[mpos + i] ^ x[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z[i] & 255) | 0;
          z[i] = u2 & 255;
          u2 >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k2, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = m2[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n2, k2) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n2[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = x[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z[i] & 255) | 0;
          z[i] = u2 & 255;
          u2 >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k2, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n2[i + 16];
      return crypto_stream_salsa20(c, cpos, d2, sn, s2);
    }
    function crypto_stream_xor(c, cpos, m2, mpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n2[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d2, sn, s2);
    }
    var poly1305 = function(key2) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key2[0] & 255 | (key2[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key2[2] & 255 | (key2[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key2[4] & 255 | (key2[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key2[6] & 255 | (key2[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key2[8] & 255 | (key2[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key2[10] & 255 | (key2[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key2[12] & 255 | (key2[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key2[14] & 255 | (key2[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
      this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
      this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
      this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
      this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
      this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
      this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
      this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m2, mpos, bytes2) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes2 >= 16) {
        t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes2 -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f2, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i = 1; i < 8; i++) {
        f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
        this.h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m2, mpos, bytes2) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes2)
          want = bytes2;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        bytes2 -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes2 >= 16) {
        want = bytes2 - bytes2 % 16;
        this.blocks(m2, mpos, want);
        mpos += want;
        bytes2 -= want;
      }
      if (bytes2) {
        for (i = 0; i < bytes2; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        this.leftover += bytes2;
      }
    };
    function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
      var s2 = new poly1305(k2);
      s2.update(m2, mpos, n2);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m2, mpos, n2, k2);
      return crypto_verify_16(h2, hpos, x, 0);
    }
    function crypto_secretbox(c, m2, d2, n2, k2) {
      var i;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c, 0, m2, 0, d2, n2, k2);
      crypto_onetimeauth(c, 16, c, 32, d2 - 32, c);
      for (i = 0; i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m2, c, d2, n2, k2) {
      var i;
      var x = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x, 0, 32, n2, k2);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d2 - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m2, 0, c, 0, d2, n2, k2);
      for (i = 0; i < 32; i++)
        m2[i] = 0;
      return 0;
    }
    function set25519(r2, a) {
      var i;
      for (i = 0; i < 16; i++)
        r2[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v2, c = 1;
      for (i = 0; i < 16; i++) {
        v2 = o[i] + c + 65535;
        c = Math.floor(v2 / 65536);
        o[i] = v2 - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p2, q2, b) {
      var t2, c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t2 = c & (p2[i] ^ q2[i]);
        p2[i] ^= t2;
        q2[i] ^= t2;
      }
    }
    function pack25519(o, n2) {
      var i, j, b;
      var m2 = gf(), t2 = gf();
      for (i = 0; i < 16; i++)
        t2[i] = n2[i];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j = 0; j < 2; j++) {
        m2[0] = t2[0] - 65517;
        for (i = 1; i < 15; i++) {
          m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
          m2[i - 1] &= 65535;
        }
        m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
        b = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t2, m2, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t2[i] & 255;
        o[2 * i + 1] = t2[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d2, b);
      return crypto_verify_32(c, 0, d2, 0);
    }
    function par25519(a) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a);
      return d2[0] & 1;
    }
    function unpack25519(o, n2) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A2(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b[i];
    }
    function Z2(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b[i];
    }
    function M2(o, a, b) {
      var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v2 = a[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b2;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b2;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b2;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b2;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b2;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b2;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b2;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b2;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b2;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b2;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b2;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b2;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b2;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b2;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b2;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b2;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M2(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S2(c, c);
        if (a !== 2 && a !== 4)
          M2(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S2(c, c);
        if (a !== 1)
          M2(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q2, n2, p2) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r2, i;
      var a = gf(), b = gf(), c = gf(), d2 = gf(), e2 = gf(), f2 = gf();
      for (i = 0; i < 31; i++)
        z[i] = n2[i];
      z[31] = n2[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p2);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d2[i] = a[i] = c[i] = 0;
      }
      a[0] = d2[0] = 1;
      for (i = 254; i >= 0; --i) {
        r2 = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r2);
        sel25519(c, d2, r2);
        A2(e2, a, c);
        Z2(a, a, c);
        A2(c, b, d2);
        Z2(b, b, d2);
        S2(d2, e2);
        S2(f2, a);
        M2(a, c, a);
        M2(c, b, e2);
        A2(e2, a, c);
        Z2(a, a, c);
        S2(b, a);
        Z2(c, d2, f2);
        M2(a, c, _121665);
        A2(a, a, d2);
        M2(c, c, a);
        M2(a, d2, f2);
        M2(d2, b, x);
        S2(b, e2);
        sel25519(a, b, r2);
        sel25519(c, d2, r2);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d2[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n2) {
      return crypto_scalarmult(q2, n2, _9);
    }
    function crypto_box_keypair(y2, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y2, x);
    }
    function crypto_box_beforenm(k2, y2, x) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x, y2);
      return crypto_core_hsalsa20(k2, _0, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m2, d2, n2, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_afternm(c, m2, d2, n2, k2);
    }
    function crypto_box_open(m2, c, d2, n2, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_open_afternm(m2, c, d2, n2, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh2, hl2, m2, n2) {
      var wh2 = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i, j, h2, l2, a, b, c, d2;
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
      var pos = 0;
      while (n2 >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh2[i] = m2[j + 0] << 24 | m2[j + 1] << 16 | m2[j + 2] << 8 | m2[j + 3];
          wl[i] = m2[j + 4] << 24 | m2[j + 5] << 16 | m2[j + 6] << 8 | m2[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l2 = al7;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K2[i * 2];
          l2 = K2[i * 2 + 1];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i % 16];
          l2 = wl[i % 16];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d2 += c >>> 16;
          th2 = c & 65535 | d2 << 16;
          tl2 = a & 65535 | b << 16;
          h2 = th2;
          l2 = tl2;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d2 += c >>> 16;
          bh7 = c & 65535 | d2 << 16;
          bl7 = a & 65535 | b << 16;
          h2 = bh3;
          l2 = bl3;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th2;
          l2 = tl2;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d2 += c >>> 16;
          bh3 = c & 65535 | d2 << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h2 = wh2[j];
              l2 = wl[j];
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j + 9) % 16];
              l2 = wl[(j + 9) % 16];
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j + 1) % 16];
              tl2 = wl[(j + 1) % 16];
              h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
              l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j + 14) % 16];
              tl2 = wl[(j + 14) % 16];
              h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
              l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d2 += c >>> 16;
              wh2[j] = c & 65535 | d2 << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h2 = ah0;
        l2 = al0;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[0];
        l2 = hl2[0];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[0] = ah0 = c & 65535 | d2 << 16;
        hl2[0] = al0 = a & 65535 | b << 16;
        h2 = ah1;
        l2 = al1;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[1];
        l2 = hl2[1];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[1] = ah1 = c & 65535 | d2 << 16;
        hl2[1] = al1 = a & 65535 | b << 16;
        h2 = ah2;
        l2 = al2;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[2];
        l2 = hl2[2];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[2] = ah2 = c & 65535 | d2 << 16;
        hl2[2] = al2 = a & 65535 | b << 16;
        h2 = ah3;
        l2 = al3;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[3];
        l2 = hl2[3];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[3] = ah3 = c & 65535 | d2 << 16;
        hl2[3] = al3 = a & 65535 | b << 16;
        h2 = ah4;
        l2 = al4;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[4];
        l2 = hl2[4];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[4] = ah4 = c & 65535 | d2 << 16;
        hl2[4] = al4 = a & 65535 | b << 16;
        h2 = ah5;
        l2 = al5;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[5];
        l2 = hl2[5];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[5] = ah5 = c & 65535 | d2 << 16;
        hl2[5] = al5 = a & 65535 | b << 16;
        h2 = ah6;
        l2 = al6;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[6];
        l2 = hl2[6];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[6] = ah6 = c & 65535 | d2 << 16;
        hl2[6] = al6 = a & 65535 | b << 16;
        h2 = ah7;
        l2 = al7;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[7];
        l2 = hl2[7];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d2 += c >>> 16;
        hh2[7] = ah7 = c & 65535 | d2 << 16;
        hl2[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n2 -= 128;
      }
      return n2;
    }
    function crypto_hash(out, m2, n2) {
      var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x = new Uint8Array(256), i, b = n2;
      hh2[0] = 1779033703;
      hh2[1] = 3144134277;
      hh2[2] = 1013904242;
      hh2[3] = 2773480762;
      hh2[4] = 1359893119;
      hh2[5] = 2600822924;
      hh2[6] = 528734635;
      hh2[7] = 1541459225;
      hl2[0] = 4089235720;
      hl2[1] = 2227873595;
      hl2[2] = 4271175723;
      hl2[3] = 1595750129;
      hl2[4] = 2917565137;
      hl2[5] = 725511199;
      hl2[6] = 4215389547;
      hl2[7] = 327033209;
      crypto_hashblocks_hl(hh2, hl2, m2, n2);
      n2 %= 128;
      for (i = 0; i < n2; i++)
        x[i] = m2[b - n2 + i];
      x[n2] = 128;
      n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
      x[n2 - 9] = 0;
      ts64(x, n2 - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh2, hl2, x, n2);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh2[i], hl2[i]);
      return 0;
    }
    function add3(p2, q2) {
      var a = gf(), b = gf(), c = gf(), d2 = gf(), e2 = gf(), f2 = gf(), g = gf(), h2 = gf(), t2 = gf();
      Z2(a, p2[1], p2[0]);
      Z2(t2, q2[1], q2[0]);
      M2(a, a, t2);
      A2(b, p2[0], p2[1]);
      A2(t2, q2[0], q2[1]);
      M2(b, b, t2);
      M2(c, p2[3], q2[3]);
      M2(c, c, D22);
      M2(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z2(e2, b, a);
      Z2(f2, d2, c);
      A2(g, d2, c);
      A2(h2, b, a);
      M2(p2[0], e2, f2);
      M2(p2[1], h2, g);
      M2(p2[2], g, f2);
      M2(p2[3], e2, h2);
    }
    function cswap(p2, q2, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p2[i], q2[i], b);
      }
    }
    function pack2(r2, p2) {
      var tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p2[2]);
      M2(tx, p2[0], zi2);
      M2(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p2, q2, s2) {
      var b, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s2[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q2, b);
        add3(q2, p2);
        add3(p2, p2);
        cswap(p2, q2, b);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p2, q2, s2);
    }
    function crypto_sign_keypair(pk2, sk2, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk2, 32);
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack2(pk2, p2);
      for (i = 0; i < 32; i++)
        sk2[i + 32] = pk2[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r2, x) {
      var carry, i, j, k2;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k2 = i - 12; j < k2; ++j) {
          x[j] += carry - 16 * x[i] * L2[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L2[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++)
        x[j] -= carry * L2[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r2[i] = x[i] & 255;
      }
    }
    function reduce(r2) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x[i] = r2[i];
      for (i = 0; i < 64; i++)
        r2[i] = 0;
      modL(r2, x);
    }
    function crypto_sign(sm, m2, n2, sk2) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i = 0; i < n2; i++)
        sm[64 + i] = m2[i];
      for (i = 0; i < 32; i++)
        sm[32 + i] = d2[32 + i];
      crypto_hash(r2, sm.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack2(sm, p2);
      for (i = 32; i < 64; i++)
        sm[i] = sk2[i];
      crypto_hash(h2, sm, n2 + 64);
      reduce(h2);
      for (i = 0; i < 64; i++)
        x[i] = 0;
      for (i = 0; i < 32; i++)
        x[i] = r2[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h2[i] * d2[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r2, p2) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M2(den, num, D2);
      Z2(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t2, den6, num);
      M2(t2, t2, den);
      pow2523(t2, t2);
      M2(t2, t2, num);
      M2(t2, t2, den);
      M2(t2, t2, den);
      M2(r2[0], t2, den);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r2[0], r2[0], I2);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r2[0]) === p2[31] >> 7)
        Z2(r2[0], gf0, r2[0]);
      M2(r2[3], r2[0], r2[1]);
      return 0;
    }
    function crypto_sign_open(m2, sm, n2, pk2) {
      var i;
      var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      if (n2 < 64)
        return -1;
      if (unpackneg(q2, pk2))
        return -1;
      for (i = 0; i < n2; i++)
        m2[i] = sm[i];
      for (i = 0; i < 32; i++)
        m2[i + 32] = pk2[i];
      crypto_hash(h2, m2, n2);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add3(p2, q2);
      pack2(t2, p2);
      n2 -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i = 0; i < n2; i++)
          m2[i] = 0;
        return -1;
      }
      for (i = 0; i < n2; i++)
        m2[i] = sm[i + 64];
      return n2;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A: A2,
      S: S2,
      Z: Z2,
      pow2523,
      add: add3,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n2) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n2.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk2, sk2) {
      if (pk2.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk2.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n2) {
      var b = new Uint8Array(n2);
      randombytes(b, n2);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key2) {
      checkArrayTypes(msg, nonce, key2);
      checkLengths(key2, nonce);
      var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m2.length);
      for (var i = 0; i < msg.length; i++)
        m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m2, m2.length, nonce, key2);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key2) {
      checkArrayTypes(box, nonce, key2);
      checkLengths(key2, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m2 = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return null;
      if (crypto_secretbox_open(m2, c, c.length, nonce, key2) !== 0)
        return null;
      return m2.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n2, p2) {
      checkArrayTypes(n2, p2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n2, p2);
      return q2;
    };
    nacl.scalarMult.base = function(n2) {
      checkArrayTypes(n2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n2);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k2);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k2);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk2, secretKey);
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m2 = new Uint8Array(mlen);
      for (var i = 0; i < m2.length; i++)
        m2[i] = tmp[i];
      return m2;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk2.length; i++)
        pk2[i] = secretKey[32 + i];
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk2[i] = seed[i];
      crypto_sign_keypair(pk2, sk2, true);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y2) {
      checkArrayTypes(x, y2);
      if (x.length === 0 || y2.length === 0)
        return false;
      if (x.length !== y2.length)
        return false;
      return vn(x, 0, y2, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto && crypto.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n2) {
          var i, v2 = new Uint8Array(n2);
          for (i = 0; i < n2; i += QUOTA) {
            crypto.getRandomValues(v2.subarray(i, i + Math.min(n2 - i, QUOTA)));
          }
          for (i = 0; i < n2; i++)
            x[i] = v2[i];
          cleanup(v2);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto = require$$0;
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n2) {
            var i, v2 = crypto.randomBytes(n2);
            for (i = 0; i < n2; i++)
              x[i] = v2[i];
            cleanup(v2);
          });
        }
      }
    })();
  })(module.exports ? module.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
var uint32$3 = { exports: {} };
(function(module) {
  /**
   * @license (c) Franz X Antesberger 2013
   */
  (function(exporter) {
    var POW_2_32 = 4294967296;
    exporter.fromBytesBigEndian = function(highByte, secondHighByte, thirdHighByte, lowByte) {
      return (highByte << 24 | secondHighByte << 16 | thirdHighByte << 8 | lowByte) >>> 0;
    };
    exporter.getByteBigEndian = function(uint32value, byteNo) {
      return uint32value >>> 8 * (3 - byteNo) & 255;
    };
    exporter.getBytesBigEndian = function(uint32value) {
      return [
        exporter.getByteBigEndian(uint32value, 0),
        exporter.getByteBigEndian(uint32value, 1),
        exporter.getByteBigEndian(uint32value, 2),
        exporter.getByteBigEndian(uint32value, 3)
      ];
    };
    exporter.toHex = function(uint32value, optionalMinLength) {
      optionalMinLength = optionalMinLength || 8;
      var result = uint32value.toString(16);
      if (result.length < optionalMinLength) {
        result = new Array(optionalMinLength - result.length + 1).join("0") + result;
      }
      return result;
    };
    exporter.toUint32 = function(number2) {
      return number2 >>> 0;
    };
    exporter.highPart = function(number2) {
      return exporter.toUint32(number2 / POW_2_32);
    };
    exporter.or = function(uint32val0, argv) {
      var result = uint32val0;
      for (var index2 = 1; index2 < arguments.length; index2 += 1) {
        result = result | arguments[index2];
      }
      return result >>> 0;
    };
    exporter.and = function(uint32val0, argv) {
      var result = uint32val0;
      for (var index2 = 1; index2 < arguments.length; index2 += 1) {
        result = result & arguments[index2];
      }
      return result >>> 0;
    };
    exporter.xor = function(uint32val0, argv) {
      var result = uint32val0;
      for (var index2 = 1; index2 < arguments.length; index2 += 1) {
        result = result ^ arguments[index2];
      }
      return result >>> 0;
    };
    exporter.not = function(uint32val) {
      return ~uint32val >>> 0;
    };
    exporter.shiftLeft = function(uint32val, numBits) {
      return uint32val << numBits >>> 0;
    };
    exporter.shiftRight = function(uint32val, numBits) {
      return uint32val >>> numBits;
    };
    exporter.rotateLeft = function(uint32val, numBits) {
      return (uint32val << numBits >>> 0 | uint32val >>> 32 - numBits) >>> 0;
    };
    exporter.rotateRight = function(uint32val, numBits) {
      return (uint32val >>> numBits | uint32val << 32 - numBits >>> 0) >>> 0;
    };
    exporter.choose = function(x, y2, z) {
      return (x & (y2 ^ z) ^ z) >>> 0;
    };
    exporter.majority = function(x, y2, z) {
      return (x & (y2 | z) | y2 & z) >>> 0;
    };
    exporter.addMod32 = function(uint32val0) {
      var result = uint32val0;
      for (var index2 = 1; index2 < arguments.length; index2 += 1) {
        result += arguments[index2];
      }
      return result >>> 0;
    };
    exporter.log2 = function(uint32val) {
      return Math.floor(Math.log(uint32val) / Math.LN2);
    };
    exporter.mult = function(factor1, factor2, resultUint32Array2) {
      var high16 = ((factor1 & 4294901760) >>> 0) * factor2;
      var low16 = (factor1 & 65535) * factor2;
      var carry = exporter.toUint32(high16) + exporter.toUint32(low16) >= POW_2_32 ? 1 : 0;
      resultUint32Array2[0] = exporter.highPart(high16) + exporter.highPart(low16) + carry >>> 0;
      resultUint32Array2[1] = (high16 >>> 0) + (low16 >>> 0);
    };
  })(module.exports = {});
})(uint32$3);
var uint32Exports = uint32$3.exports;
var uint32$2 = uint32Exports;
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
const oddsMask = uint32$2.fromBytesBigEndian(85, 85, 85, 85);
const evensMask = uint32$2.fromBytesBigEndian(170, 170, 170, 170);
const cl4 = uint32$2.fromBytesBigEndian(51, 51, 51, 51);
const ch4 = uint32$2.fromBytesBigEndian(204, 204, 204, 204);
const cl8 = uint32$2.fromBytesBigEndian(15, 15, 15, 15);
const ch8 = uint32$2.fromBytesBigEndian(240, 240, 240, 240);
const shiftRowsMask0 = uint32$2.fromBytesBigEndian(0, 0, 0, 255);
const shiftRowsMask1 = uint32$2.fromBytesBigEndian(0, 0, 252, 0);
const shiftRowsMask2 = uint32$2.fromBytesBigEndian(0, 0, 3, 0);
const shiftRowsMask3 = uint32$2.fromBytesBigEndian(0, 240, 0, 0);
const shiftRowsMask4 = uint32$2.fromBytesBigEndian(0, 15, 0, 0);
const shiftRowsMask5 = uint32$2.fromBytesBigEndian(192, 0, 0, 0);
const shiftRowsMask6 = uint32$2.fromBytesBigEndian(63, 0, 0, 0);
function newQ() {
  return new Uint32Array(8);
}
function addRoundKey(q2, sk2) {
  q2[0] = uint32$2.xor(q2[0], sk2[0]);
  q2[1] = uint32$2.xor(q2[1], sk2[1]);
  q2[2] = uint32$2.xor(q2[2], sk2[2]);
  q2[3] = uint32$2.xor(q2[3], sk2[3]);
  q2[4] = uint32$2.xor(q2[4], sk2[4]);
  q2[5] = uint32$2.xor(q2[5], sk2[5]);
  q2[6] = uint32$2.xor(q2[6], sk2[6]);
  q2[7] = uint32$2.xor(q2[7], sk2[7]);
}
function subBytes(q2) {
  const x0 = q2[7];
  const x1 = q2[6];
  const x2 = q2[5];
  const x3 = q2[4];
  const x4 = q2[3];
  const x5 = q2[2];
  const x6 = q2[1];
  const x7 = q2[0];
  const y14 = uint32$2.xor(x3, x5);
  const y13 = uint32$2.xor(x0, x6);
  const y9 = uint32$2.xor(x0, x3);
  const y8 = uint32$2.xor(x0, x5);
  const t0 = uint32$2.xor(x1, x2);
  const y1 = uint32$2.xor(t0, x7);
  const y4 = uint32$2.xor(y1, x3);
  const y12 = uint32$2.xor(y13, y14);
  const y2 = uint32$2.xor(y1, x0);
  const y5 = uint32$2.xor(y1, x6);
  const y3 = uint32$2.xor(y5, y8);
  const t1 = uint32$2.xor(x4, y12);
  const y15 = uint32$2.xor(t1, x5);
  const y20 = uint32$2.xor(t1, x1);
  const y6 = uint32$2.xor(y15, x7);
  const y10 = uint32$2.xor(y15, t0);
  const y11 = uint32$2.xor(y20, y9);
  const y7 = uint32$2.xor(x7, y11);
  const y17 = uint32$2.xor(y10, y11);
  const y19 = uint32$2.xor(y10, y8);
  const y16 = uint32$2.xor(t0, y11);
  const y21 = uint32$2.xor(y13, y16);
  const y18 = uint32$2.xor(x0, y16);
  const t2 = uint32$2.and(y12, y15);
  const t3 = uint32$2.and(y3, y6);
  const t4 = uint32$2.xor(t3, t2);
  const t5 = uint32$2.and(y4, x7);
  const t6 = uint32$2.xor(t5, t2);
  const t7 = uint32$2.and(y13, y16);
  const t8 = uint32$2.and(y5, y1);
  const t9 = uint32$2.xor(t8, t7);
  const t10 = uint32$2.and(y2, y7);
  const t11 = uint32$2.xor(t10, t7);
  const t12 = uint32$2.and(y9, y11);
  const t13 = uint32$2.and(y14, y17);
  const t14 = uint32$2.xor(t13, t12);
  const t15 = uint32$2.and(y8, y10);
  const t16 = uint32$2.xor(t15, t12);
  const t17 = uint32$2.xor(t4, t14);
  const t18 = uint32$2.xor(t6, t16);
  const t19 = uint32$2.xor(t9, t14);
  const t20 = uint32$2.xor(t11, t16);
  const t21 = uint32$2.xor(t17, y20);
  const t22 = uint32$2.xor(t18, y19);
  const t23 = uint32$2.xor(t19, y21);
  const t24 = uint32$2.xor(t20, y18);
  const t25 = uint32$2.xor(t21, t22);
  const t26 = uint32$2.and(t21, t23);
  const t27 = uint32$2.xor(t24, t26);
  const t28 = uint32$2.and(t25, t27);
  const t29 = uint32$2.xor(t28, t22);
  const t30 = uint32$2.xor(t23, t24);
  const t31 = uint32$2.xor(t22, t26);
  const t32 = uint32$2.and(t31, t30);
  const t33 = uint32$2.xor(t32, t24);
  const t34 = uint32$2.xor(t23, t33);
  const t35 = uint32$2.xor(t27, t33);
  const t36 = uint32$2.and(t24, t35);
  const t37 = uint32$2.xor(t36, t34);
  const t38 = uint32$2.xor(t27, t36);
  const t39 = uint32$2.and(t29, t38);
  const t40 = uint32$2.xor(t25, t39);
  const t41 = uint32$2.xor(t40, t37);
  const t42 = uint32$2.xor(t29, t33);
  const t43 = uint32$2.xor(t29, t40);
  const t44 = uint32$2.xor(t33, t37);
  const t45 = uint32$2.xor(t42, t41);
  const z0 = uint32$2.and(t44, y15);
  const z1 = uint32$2.and(t37, y6);
  const z2 = uint32$2.and(t33, x7);
  const z3 = uint32$2.and(t43, y16);
  const z4 = uint32$2.and(t40, y1);
  const z5 = uint32$2.and(t29, y7);
  const z6 = uint32$2.and(t42, y11);
  const z7 = uint32$2.and(t45, y17);
  const z8 = uint32$2.and(t41, y10);
  const z9 = uint32$2.and(t44, y12);
  const z10 = uint32$2.and(t37, y3);
  const z11 = uint32$2.and(t33, y4);
  const z12 = uint32$2.and(t43, y13);
  const z13 = uint32$2.and(t40, y5);
  const z14 = uint32$2.and(t29, y2);
  const z15 = uint32$2.and(t42, y9);
  const z16 = uint32$2.and(t45, y14);
  const z17 = uint32$2.and(t41, y8);
  const t46 = uint32$2.xor(z15, z16);
  const t47 = uint32$2.xor(z10, z11);
  const t48 = uint32$2.xor(z5, z13);
  const t49 = uint32$2.xor(z9, z10);
  const t50 = uint32$2.xor(z2, z12);
  const t51 = uint32$2.xor(z2, z5);
  const t52 = uint32$2.xor(z7, z8);
  const t53 = uint32$2.xor(z0, z3);
  const t54 = uint32$2.xor(z6, z7);
  const t55 = uint32$2.xor(z16, z17);
  const t56 = uint32$2.xor(z12, t48);
  const t57 = uint32$2.xor(t50, t53);
  const t58 = uint32$2.xor(z4, t46);
  const t59 = uint32$2.xor(z3, t54);
  const t60 = uint32$2.xor(t46, t57);
  const t61 = uint32$2.xor(z14, t57);
  const t62 = uint32$2.xor(t52, t58);
  const t63 = uint32$2.xor(t49, t58);
  const t64 = uint32$2.xor(z4, t59);
  const t65 = uint32$2.xor(t61, t62);
  const t66 = uint32$2.xor(z1, t63);
  const s0 = uint32$2.xor(t59, t63);
  const s6 = uint32$2.xor(t56, uint32$2.not(t62));
  const s7 = uint32$2.xor(t48, uint32$2.not(t60));
  const t67 = uint32$2.xor(t64, t65);
  const s3 = uint32$2.xor(t53, t66);
  const s4 = uint32$2.xor(t51, t66);
  const s5 = uint32$2.xor(t47, t65);
  const s1 = uint32$2.xor(t64, uint32$2.not(s3));
  const s2 = uint32$2.xor(t55, uint32$2.not(t67));
  q2[7] = s0;
  q2[6] = s1;
  q2[5] = s2;
  q2[4] = s3;
  q2[3] = s4;
  q2[2] = s5;
  q2[1] = s6;
  q2[0] = s7;
}
function shiftRows(q2) {
  for (let i = 0; i < 8; i++) {
    const x = q2[i];
    q2[i] = uint32$2.or(
      uint32$2.and(x, shiftRowsMask0),
      uint32$2.shiftRight(uint32$2.and(x, shiftRowsMask1), 2),
      uint32$2.shiftLeft(uint32$2.and(x, shiftRowsMask2), 6),
      uint32$2.shiftRight(uint32$2.and(x, shiftRowsMask3), 4),
      uint32$2.shiftLeft(uint32$2.and(x, shiftRowsMask4), 4),
      uint32$2.shiftRight(uint32$2.and(x, shiftRowsMask5), 6),
      uint32$2.shiftLeft(uint32$2.and(x, shiftRowsMask6), 2)
    );
  }
}
function mixColumns(q2) {
  const q0 = q2[0];
  const q1 = q2[1];
  const q22 = q2[2];
  const q3 = q2[3];
  const q4 = q2[4];
  const q5 = q2[5];
  const q6 = q2[6];
  const q7 = q2[7];
  const r0 = uint32$2.or(uint32$2.shiftRight(q0, 8), uint32$2.shiftLeft(q0, 24));
  const r1 = uint32$2.or(uint32$2.shiftRight(q1, 8), uint32$2.shiftLeft(q1, 24));
  const r2 = uint32$2.or(uint32$2.shiftRight(q22, 8), uint32$2.shiftLeft(q22, 24));
  const r3 = uint32$2.or(uint32$2.shiftRight(q3, 8), uint32$2.shiftLeft(q3, 24));
  const r4 = uint32$2.or(uint32$2.shiftRight(q4, 8), uint32$2.shiftLeft(q4, 24));
  const r5 = uint32$2.or(uint32$2.shiftRight(q5, 8), uint32$2.shiftLeft(q5, 24));
  const r6 = uint32$2.or(uint32$2.shiftRight(q6, 8), uint32$2.shiftLeft(q6, 24));
  const r7 = uint32$2.or(uint32$2.shiftRight(q7, 8), uint32$2.shiftLeft(q7, 24));
  q2[0] = uint32$2.xor(q7, r7, r0, uint32$2.rotateRight(uint32$2.xor(q0, r0), 16));
  q2[1] = uint32$2.xor(q0, r0, q7, r7, r1, uint32$2.rotateRight(uint32$2.xor(q1, r1), 16));
  q2[2] = uint32$2.xor(q1, r1, r2, uint32$2.rotateRight(uint32$2.xor(q22, r2), 16));
  q2[3] = uint32$2.xor(q22, r2, q7, r7, r3, uint32$2.rotateRight(uint32$2.xor(q3, r3), 16));
  q2[4] = uint32$2.xor(q3, r3, q7, r7, r4, uint32$2.rotateRight(uint32$2.xor(q4, r4), 16));
  q2[5] = uint32$2.xor(q4, r4, r5, uint32$2.rotateRight(uint32$2.xor(q5, r5), 16));
  q2[6] = uint32$2.xor(q5, r5, r6, uint32$2.rotateRight(uint32$2.xor(q6, r6), 16));
  q2[7] = uint32$2.xor(q6, r6, r7, uint32$2.rotateRight(uint32$2.xor(q7, r7), 16));
}
function load4xU32(q2, src) {
  const srcView = new DataView(src.buffer);
  q2[0] = srcView.getUint32(0 + src.byteOffset, true);
  q2[2] = srcView.getUint32(4 + src.byteOffset, true);
  q2[4] = srcView.getUint32(8 + src.byteOffset, true);
  q2[6] = srcView.getUint32(12 + src.byteOffset, true);
  q2[1] = 0;
  q2[3] = 0;
  q2[5] = 0;
  q2[7] = 0;
  ortho(q2);
}
function load8xU32(q2, src0, src1) {
  const src0View = new DataView(src0.buffer);
  const src1View = new DataView(src1.buffer);
  q2[0] = src0View.getUint32(0 + src0.byteOffset, true);
  q2[2] = src0View.getUint32(4 + src0.byteOffset, true);
  q2[4] = src0View.getUint32(8 + src0.byteOffset, true);
  q2[6] = src0View.getUint32(12 + src0.byteOffset, true);
  q2[1] = src1View.getUint32(0 + src1.byteOffset, true);
  q2[3] = src1View.getUint32(4 + src1.byteOffset, true);
  q2[5] = src1View.getUint32(8 + src1.byteOffset, true);
  q2[7] = src1View.getUint32(12 + src1.byteOffset, true);
  ortho(q2);
}
function store4xU32(dst, q2) {
  ortho(q2);
  const dstView = new DataView(dst.buffer);
  dstView.setUint32(0 + dst.byteOffset, q2[0], true);
  dstView.setUint32(4 + dst.byteOffset, q2[2], true);
  dstView.setUint32(8 + dst.byteOffset, q2[4], true);
  dstView.setUint32(12 + dst.byteOffset, q2[6], true);
}
function store8xU32(dst0, dst1, q2) {
  ortho(q2);
  const dst0View = new DataView(dst0.buffer);
  const dst1View = new DataView(dst1.buffer);
  dst0View.setUint32(0 + dst0.byteOffset, q2[0], true);
  dst0View.setUint32(4 + dst0.byteOffset, q2[2], true);
  dst0View.setUint32(8 + dst0.byteOffset, q2[4], true);
  dst0View.setUint32(12 + dst0.byteOffset, q2[6], true);
  dst1View.setUint32(0 + dst1.byteOffset, q2[1], true);
  dst1View.setUint32(4 + dst1.byteOffset, q2[3], true);
  dst1View.setUint32(8 + dst1.byteOffset, q2[5], true);
  dst1View.setUint32(12 + dst1.byteOffset, q2[7], true);
}
function ortho(q2) {
  for (let i = 0; i < 8; i += 2) {
    const q0 = q2[i];
    const q1 = q2[i + 1];
    q2[i] = uint32$2.or(uint32$2.and(q0, oddsMask), uint32$2.shiftLeft(uint32$2.and(q1, oddsMask), 1));
    q2[i + 1] = uint32$2.or(uint32$2.shiftRight(uint32$2.and(q0, evensMask), 1), uint32$2.and(q1, evensMask));
  }
  for (let i = 0; i < 8; i += 4) {
    const q0 = q2[i];
    const q1 = q2[i + 1];
    const q22 = q2[i + 2];
    const q3 = q2[i + 3];
    q2[i] = uint32$2.or(uint32$2.and(q0, cl4), uint32$2.shiftLeft(uint32$2.and(q22, cl4), 2));
    q2[i + 2] = uint32$2.or(uint32$2.shiftRight(uint32$2.and(q0, ch4), 2), uint32$2.and(q22, ch4));
    q2[i + 1] = uint32$2.or(uint32$2.and(q1, cl4), uint32$2.shiftLeft(uint32$2.and(q3, cl4), 2));
    q2[i + 3] = uint32$2.or(uint32$2.shiftRight(uint32$2.and(q1, ch4), 2), uint32$2.and(q3, ch4));
  }
  for (let i = 0; i < 4; i++) {
    const q0 = q2[i];
    const q4 = q2[i + 4];
    q2[i] = uint32$2.or(uint32$2.and(q0, cl8), uint32$2.shiftLeft(uint32$2.and(q4, cl8), 4));
    q2[i + 4] = uint32$2.or(uint32$2.shiftRight(uint32$2.and(q0, ch8), 4), uint32$2.and(q4, ch8));
  }
}
function rkeyOrtho(q2, key2) {
  const keyView = new DataView(key2.buffer);
  for (let i = 0; i < 4; i++) {
    const x = keyView.getUint32(i * 4 + key2.byteOffset, true);
    q2[i * 2] = x;
    q2[i * 2 + 1] = x;
  }
  ortho(q2);
  for (let i = 0, j = 0; i < 4; i = i + 1, j = j + 2) {
    let x = uint32$2.or(uint32$2.and(q2[j + 0], oddsMask), uint32$2.and(q2[j + 1], evensMask));
    let y2 = x;
    x = uint32$2.and(x, oddsMask);
    q2[j] = uint32$2.or(x, uint32$2.shiftLeft(x, 1));
    y2 = uint32$2.and(y2, evensMask);
    q2[j + 1] = uint32$2.or(y2, uint32$2.shiftRight(y2, 1));
  }
}
function skeyExpand(skey, numRounds, compSkey) {
  const n2 = (numRounds + 1) * 4;
  for (let u2 = 0, v2 = 0; u2 < n2; u2 = u2 + 1, v2 = v2 + 2) {
    let x = compSkey[u2];
    let y2 = compSkey[u2];
    x = uint32$2.and(x, oddsMask);
    skey[v2] = uint32$2.or(x, uint32$2.shiftLeft(x, 1));
    y2 = uint32$2.and(y2, evensMask);
    skey[v2 + 1] = uint32$2.or(y2, uint32$2.shiftRight(y2, 1));
  }
}
function _subWord(x) {
  let q2 = new Uint32Array([x, x, x, x, x, x, x, x]);
  ortho(q2);
  subBytes(q2);
  ortho(q2);
  return q2[0];
}
function keySched(compSkey, key2) {
  let numRounds = 0;
  const keyLen = key2.byteLength;
  switch (keyLen) {
    case 16:
      numRounds = 10;
      break;
    case 24:
      numRounds = 12;
      break;
    case 32:
      numRounds = 14;
      break;
    default:
      throw "aes: invalid key length";
  }
  let skey = new Uint32Array(120);
  let tmp = 0;
  const nk2 = keyLen / 4;
  const nkf = (numRounds + 1) * 4;
  const keyView = new DataView(key2.buffer);
  for (let i = 0; i < nk2; i++) {
    tmp = keyView.getUint32(i * 4 + key2.byteOffset, true);
    skey[i * 2] = tmp;
    skey[i * 2 + 1] = tmp;
  }
  for (let i = nk2, j = 0, k2 = 0; i < nkf; i++) {
    if (j == 0) {
      tmp = uint32$2.or(uint32$2.shiftLeft(tmp, 24), uint32$2.shiftRight(tmp, 8));
      tmp = uint32$2.xor(_subWord(tmp), uint32$2.fromBytesBigEndian(0, 0, 0, rcon[k2]));
    } else if (nk2 > 6 && j == 4) {
      tmp = _subWord(tmp);
    }
    tmp = uint32$2.xor(tmp, skey[(i - nk2) * 2]);
    skey[i * 2] = tmp;
    skey[i * 2 + 1] = tmp;
    j++;
    if (j == nk2) {
      j = 0;
      k2++;
    }
  }
  for (let i = 0; i < nkf; i += 4) {
    let stmp = skey.slice(i * 2, i * 2 + 8);
    ortho(stmp);
    for (let j = 0; j < 8; j++) {
      skey[i * 2 + j] = stmp[j];
    }
  }
  for (let i = 0, j = 0; i < nkf; i = i + 1, j = j + 2) {
    compSkey[i] = uint32$2.or(uint32$2.and(skey[j], oddsMask), uint32$2.and(skey[j + 1], evensMask));
  }
  return numRounds;
}
function _encrypt(numRounds, skey, q2) {
  addRoundKey(q2, skey);
  for (let u2 = 1; u2 < numRounds; u2++) {
    subBytes(q2);
    shiftRows(q2);
    mixColumns(q2);
    addRoundKey(q2, skey.slice(u2 * 8, u2 * 8 + 8));
  }
  subBytes(q2);
  shiftRows(q2);
  addRoundKey(q2, skey.slice(numRounds * 8, numRounds * 8 + 8));
}
class ECB {
  constructor(key2) {
    let skey = new Uint32Array(60);
    this.numRounds = keySched(skey, key2);
    this.skeyExpanded = new Uint32Array(120);
    skeyExpand(this.skeyExpanded, this.numRounds, skey);
  }
  encrypt(dst, src) {
    let q2 = newQ();
    load4xU32(q2, src);
    _encrypt(this.numRounds, this.skeyExpanded, q2);
    store4xU32(dst, q2);
  }
  encrypt2x(dst0, dst1, src0, src1) {
    let q2 = newQ();
    load8xU32(q2, src0, src1);
    _encrypt(this.numRounds, this.skeyExpanded, q2);
    store8xU32(dst0, dst1, q2);
  }
}
var aes$1 = {
  // ECB-AES, probably shouldn't be used for more than testing.
  ECB,
  // Implementation internals, exposed for the purpose of constructing
  // things based on the AES round function.
  newQ,
  load4xU32,
  load8xU32,
  store4xU32,
  store8xU32,
  ortho,
  rkeyOrtho,
  addRoundKey,
  subBytes,
  shiftRows,
  mixColumns,
  skeyExpand,
  keySched
};
var uint32$1 = uint32Exports;
const te0 = new Uint32Array([
  3328402341,
  4168907908,
  4000806809,
  4135287693,
  4294111757,
  3597364157,
  3731845041,
  2445657428,
  1613770832,
  33620227,
  3462883241,
  1445669757,
  3892248089,
  3050821474,
  1303096294,
  3967186586,
  2412431941,
  528646813,
  2311702848,
  4202528135,
  4026202645,
  2992200171,
  2387036105,
  4226871307,
  1101901292,
  3017069671,
  1604494077,
  1169141738,
  597466303,
  1403299063,
  3832705686,
  2613100635,
  1974974402,
  3791519004,
  1033081774,
  1277568618,
  1815492186,
  2118074177,
  4126668546,
  2211236943,
  1748251740,
  1369810420,
  3521504564,
  4193382664,
  3799085459,
  2883115123,
  1647391059,
  706024767,
  134480908,
  2512897874,
  1176707941,
  2646852446,
  806885416,
  932615841,
  168101135,
  798661301,
  235341577,
  605164086,
  461406363,
  3756188221,
  3454790438,
  1311188841,
  2142417613,
  3933566367,
  302582043,
  495158174,
  1479289972,
  874125870,
  907746093,
  3698224818,
  3025820398,
  1537253627,
  2756858614,
  1983593293,
  3084310113,
  2108928974,
  1378429307,
  3722699582,
  1580150641,
  327451799,
  2790478837,
  3117535592,
  0,
  3253595436,
  1075847264,
  3825007647,
  2041688520,
  3059440621,
  3563743934,
  2378943302,
  1740553945,
  1916352843,
  2487896798,
  2555137236,
  2958579944,
  2244988746,
  3151024235,
  3320835882,
  1336584933,
  3992714006,
  2252555205,
  2588757463,
  1714631509,
  293963156,
  2319795663,
  3925473552,
  67240454,
  4269768577,
  2689618160,
  2017213508,
  631218106,
  1269344483,
  2723238387,
  1571005438,
  2151694528,
  93294474,
  1066570413,
  563977660,
  1882732616,
  4059428100,
  1673313503,
  2008463041,
  2950355573,
  1109467491,
  537923632,
  3858759450,
  4260623118,
  3218264685,
  2177748300,
  403442708,
  638784309,
  3287084079,
  3193921505,
  899127202,
  2286175436,
  773265209,
  2479146071,
  1437050866,
  4236148354,
  2050833735,
  3362022572,
  3126681063,
  840505643,
  3866325909,
  3227541664,
  427917720,
  2655997905,
  2749160575,
  1143087718,
  1412049534,
  999329963,
  193497219,
  2353415882,
  3354324521,
  1807268051,
  672404540,
  2816401017,
  3160301282,
  369822493,
  2916866934,
  3688947771,
  1681011286,
  1949973070,
  336202270,
  2454276571,
  201721354,
  1210328172,
  3093060836,
  2680341085,
  3184776046,
  1135389935,
  3294782118,
  965841320,
  831886756,
  3554993207,
  4068047243,
  3588745010,
  2345191491,
  1849112409,
  3664604599,
  26054028,
  2983581028,
  2622377682,
  1235855840,
  3630984372,
  2891339514,
  4092916743,
  3488279077,
  3395642799,
  4101667470,
  1202630377,
  268961816,
  1874508501,
  4034427016,
  1243948399,
  1546530418,
  941366308,
  1470539505,
  1941222599,
  2546386513,
  3421038627,
  2715671932,
  3899946140,
  1042226977,
  2521517021,
  1639824860,
  227249030,
  260737669,
  3765465232,
  2084453954,
  1907733956,
  3429263018,
  2420656344,
  100860677,
  4160157185,
  470683154,
  3261161891,
  1781871967,
  2924959737,
  1773779408,
  394692241,
  2579611992,
  974986535,
  664706745,
  3655459128,
  3958962195,
  731420851,
  571543859,
  3530123707,
  2849626480,
  126783113,
  865375399,
  765172662,
  1008606754,
  361203602,
  3387549984,
  2278477385,
  2857719295,
  1344809080,
  2782912378,
  59542671,
  1503764984,
  160008576,
  437062935,
  1707065306,
  3622233649,
  2218934982,
  3496503480,
  2185314755,
  697932208,
  1512910199,
  504303377,
  2075177163,
  2824099068,
  1841019862,
  739644986
]);
const te1 = new Uint32Array([
  2781242211,
  2230877308,
  2582542199,
  2381740923,
  234877682,
  3184946027,
  2984144751,
  1418839493,
  1348481072,
  50462977,
  2848876391,
  2102799147,
  434634494,
  1656084439,
  3863849899,
  2599188086,
  1167051466,
  2636087938,
  1082771913,
  2281340285,
  368048890,
  3954334041,
  3381544775,
  201060592,
  3963727277,
  1739838676,
  4250903202,
  3930435503,
  3206782108,
  4149453988,
  2531553906,
  1536934080,
  3262494647,
  484572669,
  2923271059,
  1783375398,
  1517041206,
  1098792767,
  49674231,
  1334037708,
  1550332980,
  4098991525,
  886171109,
  150598129,
  2481090929,
  1940642008,
  1398944049,
  1059722517,
  201851908,
  1385547719,
  1699095331,
  1587397571,
  674240536,
  2704774806,
  252314885,
  3039795866,
  151914247,
  908333586,
  2602270848,
  1038082786,
  651029483,
  1766729511,
  3447698098,
  2682942837,
  454166793,
  2652734339,
  1951935532,
  775166490,
  758520603,
  3000790638,
  4004797018,
  4217086112,
  4137964114,
  1299594043,
  1639438038,
  3464344499,
  2068982057,
  1054729187,
  1901997871,
  2534638724,
  4121318227,
  1757008337,
  0,
  750906861,
  1614815264,
  535035132,
  3363418545,
  3988151131,
  3201591914,
  1183697867,
  3647454910,
  1265776953,
  3734260298,
  3566750796,
  3903871064,
  1250283471,
  1807470800,
  717615087,
  3847203498,
  384695291,
  3313910595,
  3617213773,
  1432761139,
  2484176261,
  3481945413,
  283769337,
  100925954,
  2180939647,
  4037038160,
  1148730428,
  3123027871,
  3813386408,
  4087501137,
  4267549603,
  3229630528,
  2315620239,
  2906624658,
  3156319645,
  1215313976,
  82966005,
  3747855548,
  3245848246,
  1974459098,
  1665278241,
  807407632,
  451280895,
  251524083,
  1841287890,
  1283575245,
  337120268,
  891687699,
  801369324,
  3787349855,
  2721421207,
  3431482436,
  959321879,
  1469301956,
  4065699751,
  2197585534,
  1199193405,
  2898814052,
  3887750493,
  724703513,
  2514908019,
  2696962144,
  2551808385,
  3516813135,
  2141445340,
  1715741218,
  2119445034,
  2872807568,
  2198571144,
  3398190662,
  700968686,
  3547052216,
  1009259540,
  2041044702,
  3803995742,
  487983883,
  1991105499,
  1004265696,
  1449407026,
  1316239930,
  504629770,
  3683797321,
  168560134,
  1816667172,
  3837287516,
  1570751170,
  1857934291,
  4014189740,
  2797888098,
  2822345105,
  2754712981,
  936633572,
  2347923833,
  852879335,
  1133234376,
  1500395319,
  3084545389,
  2348912013,
  1689376213,
  3533459022,
  3762923945,
  3034082412,
  4205598294,
  133428468,
  634383082,
  2949277029,
  2398386810,
  3913789102,
  403703816,
  3580869306,
  2297460856,
  1867130149,
  1918643758,
  607656988,
  4049053350,
  3346248884,
  1368901318,
  600565992,
  2090982877,
  2632479860,
  557719327,
  3717614411,
  3697393085,
  2249034635,
  2232388234,
  2430627952,
  1115438654,
  3295786421,
  2865522278,
  3633334344,
  84280067,
  33027830,
  303828494,
  2747425121,
  1600795957,
  4188952407,
  3496589753,
  2434238086,
  1486471617,
  658119965,
  3106381470,
  953803233,
  334231800,
  3005978776,
  857870609,
  3151128937,
  1890179545,
  2298973838,
  2805175444,
  3056442267,
  574365214,
  2450884487,
  550103529,
  1233637070,
  4289353045,
  2018519080,
  2057691103,
  2399374476,
  4166623649,
  2148108681,
  387583245,
  3664101311,
  836232934,
  3330556482,
  3100665960,
  3280093505,
  2955516313,
  2002398509,
  287182607,
  3413881008,
  4238890068,
  3597515707,
  975967766
]);
const te2 = new Uint32Array([
  1671808611,
  2089089148,
  2006576759,
  2072901243,
  4061003762,
  1807603307,
  1873927791,
  3310653893,
  810573872,
  16974337,
  1739181671,
  729634347,
  4263110654,
  3613570519,
  2883997099,
  1989864566,
  3393556426,
  2191335298,
  3376449993,
  2106063485,
  4195741690,
  1508618841,
  1204391495,
  4027317232,
  2917941677,
  3563566036,
  2734514082,
  2951366063,
  2629772188,
  2767672228,
  1922491506,
  3227229120,
  3082974647,
  4246528509,
  2477669779,
  644500518,
  911895606,
  1061256767,
  4144166391,
  3427763148,
  878471220,
  2784252325,
  3845444069,
  4043897329,
  1905517169,
  3631459288,
  827548209,
  356461077,
  67897348,
  3344078279,
  593839651,
  3277757891,
  405286936,
  2527147926,
  84871685,
  2595565466,
  118033927,
  305538066,
  2157648768,
  3795705826,
  3945188843,
  661212711,
  2999812018,
  1973414517,
  152769033,
  2208177539,
  745822252,
  439235610,
  455947803,
  1857215598,
  1525593178,
  2700827552,
  1391895634,
  994932283,
  3596728278,
  3016654259,
  695947817,
  3812548067,
  795958831,
  2224493444,
  1408607827,
  3513301457,
  0,
  3979133421,
  543178784,
  4229948412,
  2982705585,
  1542305371,
  1790891114,
  3410398667,
  3201918910,
  961245753,
  1256100938,
  1289001036,
  1491644504,
  3477767631,
  3496721360,
  4012557807,
  2867154858,
  4212583931,
  1137018435,
  1305975373,
  861234739,
  2241073541,
  1171229253,
  4178635257,
  33948674,
  2139225727,
  1357946960,
  1011120188,
  2679776671,
  2833468328,
  1374921297,
  2751356323,
  1086357568,
  2408187279,
  2460827538,
  2646352285,
  944271416,
  4110742005,
  3168756668,
  3066132406,
  3665145818,
  560153121,
  271589392,
  4279952895,
  4077846003,
  3530407890,
  3444343245,
  202643468,
  322250259,
  3962553324,
  1608629855,
  2543990167,
  1154254916,
  389623319,
  3294073796,
  2817676711,
  2122513534,
  1028094525,
  1689045092,
  1575467613,
  422261273,
  1939203699,
  1621147744,
  2174228865,
  1339137615,
  3699352540,
  577127458,
  712922154,
  2427141008,
  2290289544,
  1187679302,
  3995715566,
  3100863416,
  339486740,
  3732514782,
  1591917662,
  186455563,
  3681988059,
  3762019296,
  844522546,
  978220090,
  169743370,
  1239126601,
  101321734,
  611076132,
  1558493276,
  3260915650,
  3547250131,
  2901361580,
  1655096418,
  2443721105,
  2510565781,
  3828863972,
  2039214713,
  3878868455,
  3359869896,
  928607799,
  1840765549,
  2374762893,
  3580146133,
  1322425422,
  2850048425,
  1823791212,
  1459268694,
  4094161908,
  3928346602,
  1706019429,
  2056189050,
  2934523822,
  135794696,
  3134549946,
  2022240376,
  628050469,
  779246638,
  472135708,
  2800834470,
  3032970164,
  3327236038,
  3894660072,
  3715932637,
  1956440180,
  522272287,
  1272813131,
  3185336765,
  2340818315,
  2323976074,
  1888542832,
  1044544574,
  3049550261,
  1722469478,
  1222152264,
  50660867,
  4127324150,
  236067854,
  1638122081,
  895445557,
  1475980887,
  3117443513,
  2257655686,
  3243809217,
  489110045,
  2662934430,
  3778599393,
  4162055160,
  2561878936,
  288563729,
  1773916777,
  3648039385,
  2391345038,
  2493985684,
  2612407707,
  505560094,
  2274497927,
  3911240169,
  3460925390,
  1442818645,
  678973480,
  3749357023,
  2358182796,
  2717407649,
  2306869641,
  219617805,
  3218761151,
  3862026214,
  1120306242,
  1756942440,
  1103331905,
  2578459033,
  762796589,
  252780047,
  2966125488,
  1425844308,
  3151392187,
  372911126
]);
const te3 = new Uint32Array([
  1667474886,
  2088535288,
  2004326894,
  2071694838,
  4075949567,
  1802223062,
  1869591006,
  3318043793,
  808472672,
  16843522,
  1734846926,
  724270422,
  4278065639,
  3621216949,
  2880169549,
  1987484396,
  3402253711,
  2189597983,
  3385409673,
  2105378810,
  4210693615,
  1499065266,
  1195886990,
  4042263547,
  2913856577,
  3570689971,
  2728590687,
  2947541573,
  2627518243,
  2762274643,
  1920112356,
  3233831835,
  3082273397,
  4261223649,
  2475929149,
  640051788,
  909531756,
  1061110142,
  4160160501,
  3435941763,
  875846760,
  2779116625,
  3857003729,
  4059105529,
  1903268834,
  3638064043,
  825316194,
  353713962,
  67374088,
  3351728789,
  589522246,
  3284360861,
  404236336,
  2526454071,
  84217610,
  2593830191,
  117901582,
  303183396,
  2155911963,
  3806477791,
  3958056653,
  656894286,
  2998062463,
  1970642922,
  151591698,
  2206440989,
  741110872,
  437923380,
  454765878,
  1852748508,
  1515908788,
  2694904667,
  1381168804,
  993742198,
  3604373943,
  3014905469,
  690584402,
  3823320797,
  791638366,
  2223281939,
  1398011302,
  3520161977,
  0,
  3991743681,
  538992704,
  4244381667,
  2981218425,
  1532751286,
  1785380564,
  3419096717,
  3200178535,
  960056178,
  1246420628,
  1280103576,
  1482221744,
  3486468741,
  3503319995,
  4025428677,
  2863326543,
  4227536621,
  1128514950,
  1296947098,
  859002214,
  2240123921,
  1162203018,
  4193849577,
  33687044,
  2139062782,
  1347481760,
  1010582648,
  2678045221,
  2829640523,
  1364325282,
  2745433693,
  1077985408,
  2408548869,
  2459086143,
  2644360225,
  943212656,
  4126475505,
  3166494563,
  3065430391,
  3671750063,
  555836226,
  269496352,
  4294908645,
  4092792573,
  3537006015,
  3452783745,
  202118168,
  320025894,
  3974901699,
  1600119230,
  2543297077,
  1145359496,
  387397934,
  3301201811,
  2812801621,
  2122220284,
  1027426170,
  1684319432,
  1566435258,
  421079858,
  1936954854,
  1616945344,
  2172753945,
  1330631070,
  3705438115,
  572679748,
  707427924,
  2425400123,
  2290647819,
  1179044492,
  4008585671,
  3099120491,
  336870440,
  3739122087,
  1583276732,
  185277718,
  3688593069,
  3772791771,
  842159716,
  976899700,
  168435220,
  1229577106,
  101059084,
  606366792,
  1549591736,
  3267517855,
  3553849021,
  2897014595,
  1650632388,
  2442242105,
  2509612081,
  3840161747,
  2038008818,
  3890688725,
  3368567691,
  926374254,
  1835907034,
  2374863873,
  3587531953,
  1313788572,
  2846482505,
  1819063512,
  1448540844,
  4109633523,
  3941213647,
  1701162954,
  2054852340,
  2930698567,
  134748176,
  3132806511,
  2021165296,
  623210314,
  774795868,
  471606328,
  2795958615,
  3031746419,
  3334885783,
  3907527627,
  3722280097,
  1953799400,
  522133822,
  1263263126,
  3183336545,
  2341176845,
  2324333839,
  1886425312,
  1044267644,
  3048588401,
  1718004428,
  1212733584,
  50529542,
  4143317495,
  235803164,
  1633788866,
  892690282,
  1465383342,
  3115962473,
  2256965911,
  3250673817,
  488449850,
  2661202215,
  3789633753,
  4177007595,
  2560144171,
  286339874,
  1768537042,
  3654906025,
  2391705863,
  2492770099,
  2610673197,
  505291324,
  2273808917,
  3924369609,
  3469625735,
  1431699370,
  673740880,
  3755965093,
  2358021891,
  2711746649,
  2307489801,
  218961690,
  3217021541,
  3873845719,
  1111672452,
  1751693520,
  1094828930,
  2576986153,
  757954394,
  252645662,
  2964376443,
  1414855848,
  3149649517,
  370555436
]);
const andMask = uint32$1.fromBytesBigEndian(0, 0, 0, 255);
function aesencVartime(s0, s1, s2, s3, roundKey) {
  const rkView = new DataView(roundKey.buffer);
  const rk0 = rkView.getUint32(0 + roundKey.byteOffset, false);
  const rk1 = rkView.getUint32(4 + roundKey.byteOffset, false);
  const rk2 = rkView.getUint32(8 + roundKey.byteOffset, false);
  const rk3 = rkView.getUint32(12 + roundKey.byteOffset, false);
  const t0 = uint32$1.xor(
    te0[uint32$1.and(uint32$1.shiftRight(s0, 24), andMask)],
    te1[uint32$1.and(uint32$1.shiftRight(s1, 16), andMask)],
    te2[uint32$1.and(uint32$1.shiftRight(s2, 8), andMask)],
    te3[uint32$1.and(s3, andMask)],
    rk0
  );
  const t1 = uint32$1.xor(
    te0[uint32$1.and(uint32$1.shiftRight(s1, 24), andMask)],
    te1[uint32$1.and(uint32$1.shiftRight(s2, 16), andMask)],
    te2[uint32$1.and(uint32$1.shiftRight(s3, 8), andMask)],
    te3[uint32$1.and(s0, andMask)],
    rk1
  );
  const t2 = uint32$1.xor(
    te0[uint32$1.and(uint32$1.shiftRight(s2, 24), andMask)],
    te1[uint32$1.and(uint32$1.shiftRight(s3, 16), andMask)],
    te2[uint32$1.and(uint32$1.shiftRight(s0, 8), andMask)],
    te3[uint32$1.and(s1, andMask)],
    rk2
  );
  const t3 = uint32$1.xor(
    te0[uint32$1.and(uint32$1.shiftRight(s3, 24), andMask)],
    te1[uint32$1.and(uint32$1.shiftRight(s0, 16), andMask)],
    te2[uint32$1.and(uint32$1.shiftRight(s1, 8), andMask)],
    te3[uint32$1.and(s2, andMask)],
    rk3
  );
  return [t0, t1, t2, t3];
}
var unsafe$1 = {
  aesencVartime
};
var aes = aes$1;
var uint32 = uint32Exports;
var unsafe = unsafe$1;
const KeySize = 32;
const NonceSize = 15;
const TagSize = 16;
const stkSize = 16;
const rounds = 16;
const blockSize = 16;
const tweakSize = 16;
const prefixADBlock = 2;
const prefixADFinal = 6;
const prefixMsgBlock = 0;
const prefixMsgFinal = 4;
const prefixTag = 1;
const prefixShift = 4;
function xorBytes(dst, a, b, n2) {
  for (let i = 0; i < n2; i++) {
    dst[i] = a[i] ^ b[i];
  }
}
const rcons = new Uint8Array([
  47,
  94,
  188,
  99,
  198,
  151,
  53,
  106,
  212,
  179,
  125,
  250,
  239,
  197,
  145,
  57,
  114
]);
function h(t2) {
  const tmp = new Uint8Array([
    t2[1],
    t2[6],
    t2[11],
    t2[12],
    t2[5],
    t2[10],
    t2[15],
    t2[0],
    t2[9],
    t2[14],
    t2[3],
    t2[4],
    t2[13],
    t2[2],
    t2[7],
    t2[8]
  ]);
  t2.set(tmp);
}
function lfsr2(t2) {
  for (let i = 0; i < stkSize; i++) {
    const x = t2[i];
    const x7 = x >> 7;
    const x5 = x >> 5 & 1;
    t2[i] = x << 1 | x7 ^ x5;
  }
}
function lfsr3(t2) {
  for (let i = 0; i < stkSize; i++) {
    const x = t2[i];
    const x0 = x & 1;
    const x6 = x >> 6 & 1;
    t2[i] = x >> 1 | (x0 ^ x6) << 7;
  }
}
function xorRC(t2, i) {
  t2[0] ^= 1;
  t2[1] ^= 2;
  t2[2] ^= 4;
  t2[3] ^= 8;
  t2[4] ^= rcons[i];
  t2[5] ^= rcons[i];
  t2[6] ^= rcons[i];
  t2[7] ^= rcons[i];
}
function stkDeriveK(key2, derivedKs) {
  let tk2 = key2.subarray(16, 32);
  let tk3 = key2.subarray(0, 16);
  xorBytes(derivedKs[0], tk2, tk3, stkSize);
  xorRC(derivedKs[0], 0);
  for (let i = 1; i <= rounds; i++) {
    lfsr2(tk2);
    h(tk2);
    lfsr3(tk3);
    h(tk3);
    xorBytes(derivedKs[i], tk2, tk3, stkSize);
    xorRC(derivedKs[i], i);
  }
}
function deriveSubTweakKeys(stks, derivedKs, tweak) {
  let tk1 = new Uint8Array(tweak);
  xorBytes(stks[0], derivedKs[0], tk1, stkSize);
  for (let i = 1; i <= rounds; i++) {
    h(tk1);
    xorBytes(stks[i], derivedKs[i], tk1, stkSize);
  }
}
function newStks() {
  let stks = [];
  for (let i = 0; i <= rounds; i++) {
    stks.push(new Uint8Array(16));
  }
  return stks;
}
class implCt32 {
  /**
   * @param {Uint8Array} ciphertext
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array} tweak
   * @param {Uint8Array} plaintext
   */
  static bcEncrypt(ciphertext, derivedKs, tweak, plaintext) {
    let stks = newStks();
    deriveSubTweakKeys(stks, derivedKs, tweak);
    let q2 = aes.newQ(), stk = aes.newQ();
    aes.load4xU32(q2, plaintext);
    aes.load4xU32(stk, stks[0]);
    aes.addRoundKey(q2, stk);
    for (let i = 1; i <= rounds; i++) {
      aes.subBytes(q2);
      aes.shiftRows(q2);
      aes.mixColumns(q2);
      aes.load4xU32(stk, stks[i]);
      aes.addRoundKey(q2, stk);
    }
    aes.store4xU32(ciphertext, q2);
  }
  /**
   * @param {Uint8Array} ciphertext
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array[]} tweaks
   * @param {Uint8Array} nonce
   */
  static bcKeystreamx2(ciphertext, derivedKs, tweaks, nonce) {
    let stks = [newStks(), newStks()];
    for (let i = 0; i < 2; i++) {
      deriveSubTweakKeys(stks[i], derivedKs, tweaks[i]);
    }
    let q2 = aes.newQ(), stk = aes.newQ();
    aes.rkeyOrtho(q2, nonce);
    aes.load8xU32(stk, stks[0][0], stks[1][0]);
    aes.addRoundKey(q2, stk);
    for (let i = 1; i <= rounds; i++) {
      aes.subBytes(q2);
      aes.shiftRows(q2);
      aes.mixColumns(q2);
      aes.load8xU32(stk, stks[0][i], stks[1][i]);
      aes.addRoundKey(q2, stk);
    }
    aes.store8xU32(ciphertext.subarray(0, 16), ciphertext.subarray(16, 32), q2);
  }
  /**
   * @param {Uint8Array} tag
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array} tweak
   * @param {Uint8Array} plaintext
   */
  static bcTagx1(tag, derivedKs, tweak, plaintext) {
    let stks = newStks();
    deriveSubTweakKeys(stks, derivedKs, tweak);
    let q2 = aes.newQ(), stk = aes.newQ();
    aes.load4xU32(q2, plaintext);
    aes.load4xU32(stk, stks[0]);
    aes.addRoundKey(q2, stk);
    for (let i = 1; i <= rounds; i++) {
      aes.subBytes(q2);
      aes.shiftRows(q2);
      aes.mixColumns(q2);
      aes.load4xU32(stk, stks[i]);
      aes.addRoundKey(q2, stk);
    }
    const tagView = new DataView(tag.buffer);
    let tag0 = tagView.getUint32(0, true);
    let tag1 = tagView.getUint32(4, true);
    let tag2 = tagView.getUint32(8, true);
    let tag3 = tagView.getUint32(12, true);
    aes.ortho(q2);
    tag0 = uint32.xor(tag0, q2[0]);
    tag1 = uint32.xor(tag1, q2[2]);
    tag2 = uint32.xor(tag2, q2[4]);
    tag3 = uint32.xor(tag3, q2[6]);
    tagView.setUint32(0, tag0, true);
    tagView.setUint32(4, tag1, true);
    tagView.setUint32(8, tag2, true);
    tagView.setUint32(12, tag3, true);
  }
  /**
   * @param {Uint8Array} tag
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array[]} tweaks
   * @param {Uint8Array} plaintext
   */
  static bcTagx2(tag, derivedKs, tweaks, plaintext) {
    let stks = [newStks(), newStks()];
    for (let i = 0; i < 2; i++) {
      deriveSubTweakKeys(stks[i], derivedKs, tweaks[i]);
    }
    let q2 = aes.newQ(), stk = aes.newQ();
    aes.load8xU32(q2, plaintext.subarray(0, 16), plaintext.subarray(16, 32));
    aes.load8xU32(stk, stks[0][0], stks[1][0]);
    aes.addRoundKey(q2, stk);
    for (let i = 1; i <= rounds; i++) {
      aes.subBytes(q2);
      aes.shiftRows(q2);
      aes.mixColumns(q2);
      aes.load8xU32(stk, stks[0][i], stks[1][i]);
      aes.addRoundKey(q2, stk);
    }
    const tagView = new DataView(tag.buffer);
    let tag0 = tagView.getUint32(0, true);
    let tag1 = tagView.getUint32(4, true);
    let tag2 = tagView.getUint32(8, true);
    let tag3 = tagView.getUint32(12, true);
    aes.ortho(q2);
    tag0 = uint32.xor(tag0, q2[0], q2[1]);
    tag1 = uint32.xor(tag1, q2[2], q2[3]);
    tag2 = uint32.xor(tag2, q2[4], q2[5]);
    tag3 = uint32.xor(tag3, q2[6], q2[7]);
    tagView.setUint32(0, tag0, true);
    tagView.setUint32(4, tag1, true);
    tagView.setUint32(8, tag2, true);
    tagView.setUint32(12, tag3, true);
  }
}
class implUnsafeVartime {
  /**
   * @param {Uint8Array} ciphertext
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array} tweak
   * @param {Uint8Array} plaintext
   */
  static bcEncrypt(ciphertext, derivedKs, tweak, plaintext) {
    let stks = newStks();
    deriveSubTweakKeys(stks, derivedKs, tweak);
    const plainView = new DataView(plaintext.buffer);
    let s0 = plainView.getUint32(0 + plaintext.byteOffset, false);
    let s1 = plainView.getUint32(4 + plaintext.byteOffset, false);
    let s2 = plainView.getUint32(8 + plaintext.byteOffset, false);
    let s3 = plainView.getUint32(12 + plaintext.byteOffset, false);
    const stksView = new DataView(stks[0].buffer);
    s0 = uint32.xor(s0, stksView.getUint32(0 + stks[0].byteOffset, false));
    s1 = uint32.xor(s1, stksView.getUint32(4 + stks[0].byteOffset, false));
    s2 = uint32.xor(s2, stksView.getUint32(8 + stks[0].byteOffset, false));
    s3 = uint32.xor(s3, stksView.getUint32(12 + stks[0].byteOffset, false));
    for (let i = 1; i <= rounds; i++) {
      [s0, s1, s2, s3] = unsafe.aesencVartime(s0, s1, s2, s3, stks[i]);
    }
    const cipherView = new DataView(ciphertext.buffer);
    cipherView.setUint32(0 + ciphertext.byteOffset, s0, false);
    cipherView.setUint32(4 + ciphertext.byteOffset, s1, false);
    cipherView.setUint32(8 + ciphertext.byteOffset, s2, false);
    cipherView.setUint32(12 + ciphertext.byteOffset, s3, false);
  }
  /**
   * @param {Uint8Array} ciphertext
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array[]} tweaks
   * @param {Uint8Array} nonce
   */
  static bcKeystreamx2(ciphertext, derivedKs, tweaks, nonce) {
    this.bcEncrypt(ciphertext.subarray(0, 16), derivedKs, tweaks[0], nonce);
    this.bcEncrypt(ciphertext.subarray(16, 32), derivedKs, tweaks[1], nonce);
  }
  /**
   * @param {Uint8Array} tag
   * @param {Uint8Array[]} derivedKs
   * @param {Uint8Array} tweak
   * @param {Uint8Array} plaintext
   */
  static bcTagx1(tag, derivedKs, tweak, plaintext) {
    let tmp = new Uint8Array(blockSize);
    this.bcEncrypt(tmp, derivedKs, tweak, plaintext);
    xorBytes(tag, tag, tmp, blockSize);
  }
  /**
  * @param {Uint8Array} tag
  * @param {Uint8Array[]} derivedKs
  * @param {Uint8Array[]} tweaks
  * @param {Uint8Array} plaintext
  */
  static bcTagx2(tag, derivedKs, tweaks, plaintext) {
    let tmp = new Uint8Array(2 * blockSize);
    this.bcEncrypt(tmp.subarray(0, 16), derivedKs, tweaks[0], plaintext.subarray(0, 16));
    this.bcEncrypt(tmp.subarray(16, 32), derivedKs, tweaks[1], plaintext.subarray(16, 32));
    xorBytes(tag, tag, tmp.subarray(0, 16), blockSize);
    xorBytes(tag, tag, tmp.subarray(16, 32), blockSize);
  }
}
function encodeTagTweak(out, prefix, blockNr) {
  out.set(new Uint8Array(12));
  new DataView(out.buffer).setUint32(12 + out.byteOffset, blockNr, false);
  out[0] = prefix << prefixShift;
}
function encodeEncTweak(out, tag, blockNr) {
  var tmp = new Uint8Array(4);
  new DataView(tmp.buffer).setUint32(0, blockNr, false);
  out.set(tag);
  out[0] |= 128;
  xorBytes(out.subarray(12, 16), out.subarray(12, 16), tmp, 4);
}
function newTweaks() {
  let tweaks = [];
  for (let i = 0; i < 2; i++) {
    tweaks.push(new Uint8Array(tweakSize));
  }
  return tweaks;
}
function e(impl, derivedKs, nonce, dst, ad2, msg) {
  let tweaks = newTweaks();
  let i = 0, j = 0;
  let adLen = ad2.length;
  let auth = new Uint8Array(TagSize);
  for (i = 0; adLen >= 2 * blockSize; i += 2) {
    encodeTagTweak(tweaks[0], prefixADBlock, i);
    encodeTagTweak(tweaks[1], prefixADBlock, i + 1);
    impl.bcTagx2(auth, derivedKs, tweaks, ad2.subarray(i * blockSize, (i + 2) * blockSize));
    adLen -= 2 * blockSize;
  }
  for (; adLen >= blockSize; i++) {
    encodeTagTweak(tweaks[0], prefixADBlock, i);
    impl.bcTagx1(auth, derivedKs, tweaks[0], ad2.subarray(i * blockSize, (i + 1) * blockSize));
    adLen -= blockSize;
  }
  if (adLen > 0) {
    encodeTagTweak(tweaks[0], prefixADFinal, i);
    let aStar = new Uint8Array(blockSize);
    aStar.set(ad2.subarray(ad2.length - adLen));
    aStar[adLen] = 128;
    impl.bcTagx1(auth, derivedKs, tweaks[0], aStar);
  }
  let msgLen = msg.length;
  for (j = 0; msgLen >= 2 * blockSize; j += 2) {
    encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    encodeTagTweak(tweaks[1], prefixMsgBlock, j + 1);
    impl.bcTagx2(auth, derivedKs, tweaks, msg.subarray(j * blockSize, (j + 2) * blockSize));
    msgLen -= 2 * blockSize;
  }
  for (; msgLen >= blockSize; j++) {
    encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    impl.bcTagx1(auth, derivedKs, tweaks[0], msg.subarray(j * blockSize, (j + 1) * blockSize));
    msgLen -= blockSize;
  }
  if (msgLen > 0) {
    encodeTagTweak(tweaks[0], prefixMsgFinal, j);
    let mStar = new Uint8Array(blockSize);
    mStar.set(msg.subarray(msg.length - msgLen));
    mStar[msgLen] = 128;
    impl.bcTagx1(auth, derivedKs, tweaks[0], mStar);
  }
  let encNonce = new Uint8Array(blockSize);
  encNonce.set(nonce, 1);
  encNonce[0] = prefixTag << prefixShift;
  impl.bcEncrypt(auth, derivedKs, encNonce, auth);
  encNonce[0] = 0;
  msgLen = msg.length;
  let encBlks = new Uint8Array(2 * blockSize);
  for (j = 0; msgLen >= 2 * blockSize; j += 2) {
    encodeEncTweak(tweaks[0], auth, j);
    encodeEncTweak(tweaks[1], auth, j + 1);
    impl.bcKeystreamx2(encBlks, derivedKs, tweaks, encNonce);
    xorBytes(dst.subarray(j * blockSize, (j + 2) * blockSize), msg.subarray(j * blockSize, (j + 2) * blockSize), encBlks, 2 * blockSize);
    msgLen -= 2 * blockSize;
  }
  for (; msgLen >= blockSize; j++) {
    encodeEncTweak(tweaks[0], auth, j);
    impl.bcEncrypt(encBlks, derivedKs, tweaks[0], encNonce);
    xorBytes(dst.subarray(j * blockSize, (j + 1) * blockSize), msg.subarray(j * blockSize, (j + 1) * blockSize), encBlks, blockSize);
    msgLen -= blockSize;
  }
  if (msgLen > 0) {
    encodeEncTweak(tweaks[0], auth, j);
    impl.bcEncrypt(encBlks, derivedKs, tweaks[0], encNonce);
    xorBytes(dst.subarray(j * blockSize, msg.length), msg.subarray(j * blockSize), encBlks, msgLen);
  }
  dst.set(auth, msg.length);
}
function d(impl, derivedKs, nonce, dst, ad2, ct) {
  let ctLen = ct.length - TagSize;
  const ciphertext = ct.subarray(0, ctLen);
  const tag = ct.subarray(ctLen);
  let j = 0;
  let decTweaks = newTweaks();
  let decNonce = new Uint8Array(blockSize);
  decNonce.set(nonce, 1);
  let decBlks = new Uint8Array(2 * blockSize);
  for (j = 0; ctLen >= 2 * blockSize; j += 2) {
    encodeEncTweak(decTweaks[0], tag, j);
    encodeEncTweak(decTweaks[1], tag, j + 1);
    impl.bcKeystreamx2(decBlks, derivedKs, decTweaks, decNonce);
    xorBytes(dst.subarray(j * blockSize, (j + 2) * blockSize), ciphertext.subarray(j * blockSize, (j + 2) * blockSize), decBlks, 2 * blockSize);
    ctLen -= 2 * blockSize;
  }
  for (; ctLen >= blockSize; j++) {
    encodeEncTweak(decTweaks[0], tag, j);
    impl.bcEncrypt(decBlks, derivedKs, decTweaks[0], decNonce);
    xorBytes(dst.subarray(j * blockSize, (j + 1) * blockSize), ciphertext.subarray(j * blockSize, (j + 1) * blockSize), decBlks, blockSize);
    ctLen -= blockSize;
  }
  if (ctLen > 0) {
    encodeEncTweak(decTweaks[0], tag, j);
    impl.bcEncrypt(decBlks, derivedKs, decTweaks[0], decNonce);
    xorBytes(dst.subarray(j * blockSize), ciphertext.subarray(j * blockSize), decBlks, ctLen);
  }
  let i = 0;
  let adLen = ad2.length;
  let tweaks = newTweaks();
  let auth = new Uint8Array(TagSize);
  for (i = 0; adLen >= 2 * blockSize; i += 2) {
    encodeTagTweak(tweaks[0], prefixADBlock, i);
    encodeTagTweak(tweaks[1], prefixADBlock, i + 1);
    impl.bcTagx2(auth, derivedKs, tweaks, ad2.subarray(i * blockSize, (i + 2) * blockSize));
    adLen -= 2 * blockSize;
  }
  for (; adLen >= blockSize; i++) {
    encodeTagTweak(tweaks[0], prefixADBlock, i);
    impl.bcTagx1(auth, derivedKs, tweaks[0], ad2.subarray(i * blockSize, (i + 1) * blockSize));
    adLen -= blockSize;
  }
  if (adLen > 0) {
    encodeTagTweak(tweaks[0], prefixADFinal, i);
    let aStar = new Uint8Array(blockSize);
    aStar.set(ad2.subarray(ad2.length - adLen));
    aStar[adLen] = 128;
    impl.bcTagx1(auth, derivedKs, tweaks[0], aStar);
  }
  let msgLen = dst.length;
  for (j = 0; msgLen >= 2 * blockSize; j += 2) {
    encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    encodeTagTweak(tweaks[1], prefixMsgBlock, j + 1);
    impl.bcTagx2(auth, derivedKs, tweaks, dst.subarray(j * blockSize, (j + 2) * blockSize));
    msgLen -= 2 * blockSize;
  }
  for (; msgLen >= blockSize; j++) {
    encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    impl.bcTagx1(auth, derivedKs, tweaks[0], dst.subarray(j * blockSize, (j + 1) * blockSize));
    msgLen -= blockSize;
  }
  if (msgLen > 0) {
    encodeTagTweak(tweaks[0], prefixMsgFinal, j);
    let mStar = new Uint8Array(blockSize);
    mStar.set(dst.subarray(dst.length - msgLen));
    mStar[msgLen] = 128;
    impl.bcTagx1(auth, derivedKs, tweaks[0], mStar);
  }
  decNonce[0] = prefixTag << prefixShift;
  impl.bcEncrypt(auth, derivedKs, decNonce, auth);
  if (auth.length != tag.length) {
    return false;
  }
  let eql = true;
  for (i = 0; i < auth.length; i++) {
    eql &= !(auth[i] ^ tag[i]);
  }
  return eql;
}
class AEAD {
  /**
   * @param {Uint8Array} key
   * @param {boolean} useUnsafeVartime
   */
  constructor(key2, useUnsafeVartime = false) {
    if (key2.length != KeySize) {
      throw ErrKeySize;
    }
    this.impl = useUnsafeVartime ? implUnsafeVartime : implCt32;
    this.derivedKs = newStks();
    stkDeriveK(key2, this.derivedKs);
  }
  /**
   * @param {Uint8Array} nonce
   * @param {Uint8Array | null} plaintext
   * @param {Uint8Array | null} associatedData
   */
  encrypt(nonce, plaintext = null, associatedData = null) {
    if (nonce.length != NonceSize) {
      throw ErrNonceSize;
    }
    if (plaintext == null) {
      plaintext = zeroBuffer;
    }
    if (associatedData == null) {
      associatedData = zeroBuffer;
    }
    let dst = new Uint8Array(plaintext.length + TagSize);
    e(this.impl, this.derivedKs, nonce, dst, associatedData, plaintext);
    return dst;
  }
  /**
   * @param {Uint8Array} nonce
   * @param {Uint8Array} ciphertext
   * @param {Uint8Array | null} associatedData
   */
  decrypt(nonce, ciphertext, associatedData = null) {
    if (nonce.length != NonceSize) {
      throw ErrNonceSize;
    }
    if (ciphertext.length < TagSize) {
      throw ErrOpen;
    }
    if (associatedData == null) {
      associatedData = zeroBuffer;
    }
    let dst = new Uint8Array(ciphertext.length - TagSize);
    if (!d(this.impl, this.derivedKs, nonce, dst, associatedData, ciphertext)) {
      dst.set(new Uint8Array(dst.length));
      throw ErrOpen;
    }
    return dst;
  }
}
const zeroBuffer = new Uint8Array(0);
const ErrKeySize = "deoxysii: invalid key size";
const ErrNonceSize = "deoxysii: invalid nonce size";
const ErrOpen = "deoxysii: message authentication failure";
var deoxysii = {
  KeySize,
  NonceSize,
  TagSize,
  ErrNonceSize,
  ErrKeySize,
  ErrOpen,
  AEAD
};
function evaluateThis(fn) {
  return fn("return this");
}
const xglobal = (
  /* eslint-disable no-restricted-globals */
  typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function)
);
const REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
const REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
const U8_TO_HEX = new Array(256);
const U16_TO_HEX = new Array(256 * 256);
const HEX_TO_U8 = {};
const HEX_TO_U16 = {};
for (let n2 = 0; n2 < 256; n2++) {
  const hex2 = n2.toString(16).padStart(2, "0");
  U8_TO_HEX[n2] = hex2;
  HEX_TO_U8[hex2] = n2;
}
for (let i = 0; i < 256; i++) {
  for (let j = 0; j < 256; j++) {
    const hex2 = U8_TO_HEX[i] + U8_TO_HEX[j];
    const n2 = i << 8 | j;
    U16_TO_HEX[n2] = hex2;
    HEX_TO_U16[hex2] = n2;
  }
}
class BasicTextEncoder {
  encode(value) {
    const u8a = new Uint8Array(value.length);
    for (let i = 0; i < value.length; i++) {
      u8a[i] = value.charCodeAt(i);
    }
    return u8a;
  }
}
const TextEncoder$1 = typeof xglobal.TextEncoder === "undefined" ? BasicTextEncoder : xglobal.TextEncoder;
class BasicTextDecoder {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-useless-constructor
  constructor(_) {
  }
  decode(value) {
    let result = "";
    for (let i = 0; i < value.length; i++) {
      result += String.fromCharCode(value[i]);
    }
    return result;
  }
}
typeof xglobal.TextEncoder === "undefined" ? BasicTextDecoder : xglobal.TextDecoder;
const encoder = new TextEncoder$1();
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}
function u8aConcat(...list) {
  let length = 0;
  let offset = 0;
  const u8as = new Array(list.length);
  for (let i = 0; i < list.length; i++) {
    u8as[i] = list[i];
    length += u8as[i].length;
  }
  const result = new Uint8Array(length);
  for (let i = 0; i < u8as.length; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }
  return result;
}
function hexToU8a(_value, bitLength = -1) {
  if (!_value) {
    return new Uint8Array();
  }
  const value = hexStripPrefix(_value).toLowerCase();
  const valLength = value.length / 2;
  const endLength = Math.ceil(bitLength === -1 ? valLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > valLength ? endLength - valLength : 0;
  const dv = new DataView(result.buffer, offset);
  const mod = (endLength - offset) % 2;
  const length = endLength - offset - mod;
  for (let i = 0; i < length; i += 2) {
    dv.setUint16(i, HEX_TO_U16[value.substr(i * 2, 4)]);
  }
  if (mod) {
    dv.setUint8(length, HEX_TO_U8[value.substr(value.length - 2, 2)]);
  }
  return result;
}
function hexStripPrefix(value) {
  if (!value || value === "0x") {
    return "";
  }
  if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substr(2);
  }
  if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const length = Math.ceil(bitLength / 8);
  return `${isPrefixed ? "0x" : ""}${!value || !value.length ? "" : length > 0 && value.length > length ? `${hex(value.subarray(0, length / 2))}…${hex(value.subarray(value.length - length / 2))}` : hex(value)}`;
}
function hex(value) {
  const mod = value.length % 2;
  const length = value.length - mod;
  const dv = new DataView(value.buffer, value.byteOffset);
  let result = "";
  for (let i = 0; i < length; i += 2) {
    result += U16_TO_HEX[dv.getUint16(i)];
  }
  if (mod) {
    result += U8_TO_HEX[dv.getUint8(length)];
  }
  return result;
}
const TX_KEY_PREFIX = "IOEncryptionKeyV1";
const USER_KEY_PREFIX = "UserEncryptionKeyV1";
function deriveEncryptionKey(privateKey, salt) {
  return hmac2.create(sha256, salt).update(privateKey).digest();
}
function deriveSharedSecret(privateKey, publicKey) {
  return naclFastExports.scalarMult(privateKey, publicKey);
}
function getX25519PublicKey(privateKey) {
  return naclFastExports.scalarMult.base(privateKey);
}
function encryptECDH(privateKey, nodePublicKey, data) {
  try {
    const sharedSecret = deriveSharedSecret(privateKey, nodePublicKey);
    const encryptionKey = deriveEncryptionKey(sharedSecret, stringToU8a(TX_KEY_PREFIX));
    const encryptionResult = encrypt(encryptionKey, data);
    if (encryptionResult.error) {
      return encryptionResult;
    }
    const userPublicKey = getX25519PublicKey(privateKey);
    return { result: u8aConcat(userPublicKey, encryptionResult.result) };
  } catch (e2) {
    if (typeof e2 === "string") {
      return { error: e2 };
    } else if (e2 instanceof Error) {
      return { error: e2.message };
    } else {
      return { error: "encryptECDH error" };
    }
  }
}
function decryptECDH(privateKey, nodePublicKey, encryptedData) {
  try {
    const sharedSecret = deriveSharedSecret(privateKey, nodePublicKey);
    const encryptionKey = deriveEncryptionKey(sharedSecret, stringToU8a(TX_KEY_PREFIX));
    return decrypt(encryptionKey, encryptedData);
  } catch (e2) {
    if (typeof e2 === "string") {
      return { error: e2 };
    } else if (e2 instanceof Error) {
      return { error: e2.message };
    } else {
      return { error: "decryptECDH error" };
    }
  }
}
function encrypt(privateKey, data) {
  try {
    const nonce = naclFastExports.randomBytes(deoxysii.NonceSize);
    const ad2 = naclFastExports.randomBytes(deoxysii.TagSize);
    const cipher = new deoxysii.AEAD(privateKey);
    const ciphertext = cipher.encrypt(nonce, data, ad2);
    const encryptedData = u8aConcat(nonce, ad2, ciphertext);
    return { result: encryptedData };
  } catch (e2) {
    if (typeof e2 === "string") {
      return { error: e2 };
    } else if (e2 instanceof Error) {
      return { error: e2.message };
    } else {
      return { error: "decryption error" };
    }
  }
}
function decrypt(privateKey, encryptedData) {
  try {
    const nonce = encryptedData.subarray(0, deoxysii.NonceSize);
    const ad2 = encryptedData.subarray(deoxysii.NonceSize, deoxysii.NonceSize + deoxysii.TagSize);
    const ciphertext = encryptedData.subarray(deoxysii.NonceSize + deoxysii.TagSize);
    const cipher = new deoxysii.AEAD(privateKey);
    const plaintext = cipher.decrypt(nonce, ciphertext, ad2);
    return { result: plaintext };
  } catch (e2) {
    if (typeof e2 === "string") {
      return { error: e2 };
    } else if (e2 instanceof Error) {
      return { error: e2.message };
    } else {
      return { error: "decryption error" };
    }
  }
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key2) => {
    if (thisArg && isFunction(val)) {
      a[key2] = bind(val, thisArg);
    } else {
      a[key2] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key2) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key2) {
  return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path, key2, dots) {
  if (!path)
    return key2;
  return path.concat(key2).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el2, index2) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el2, key2) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key2) ? key2.trim() : key2,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder2) {
  const _encode3 = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each(pair) {
    return _encode3(pair[0]) + "=" + _encode3(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode3 = options && options.encode || encode$1;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode3);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key2 = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils$1.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$1.findKey(this, header);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$1.findKey(this, header);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$1.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key2 = keys[i];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key2 = utils$1.findKey(headers, header);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils$1.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.6.5";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key2, value]) => {
  HttpStatusCode[value] = key2;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
async function getNodePublicKey(rpcEndpoint, options) {
  let blockNumOrHash = "latest";
  if (options) {
    if (options.blockHash) {
      blockNumOrHash = options.blockHash;
    }
    if (options.blockNumber) {
      blockNumOrHash = options.blockNumber;
    }
  }
  const requestData = {
    id: 1,
    jsonrpc: "2.0",
    method: "eth_getNodePublicKey",
    params: [blockNumOrHash]
  };
  try {
    const { data } = await axios$1.post(rpcEndpoint, requestData);
    if (!data.result) {
      throw new Error("corrupted response");
    }
    return { publicKey: data.result };
  } catch (err) {
    if (axios$1.isAxiosError(err)) {
      return { error: err.message };
    } else {
      return {
        error: `Cannot get node public key: an unexpected error occurred: ${err}`
      };
    }
  }
}
async function encryptDataField(nodeURL, data, userEncryptionKey) {
  userEncryptionKey = userEncryptionKey ?? naclFastExports.randomBytes(32);
  const encryptionPrivateKey = deriveEncryptionKey(userEncryptionKey, stringToU8a(USER_KEY_PREFIX));
  const nodePublicKeyResponse = await getNodePublicKey(nodeURL);
  if (!nodePublicKeyResponse.publicKey) {
    throw new Error(`Cannot obtain node public key. Reason: ${nodePublicKeyResponse.error}`);
  }
  const nodePublicKey = nodePublicKeyResponse.publicKey;
  const encryptionResult = encryptECDH(encryptionPrivateKey, hexToU8a(nodePublicKey), hexToU8a(data));
  if (!encryptionResult.result) {
    throw new Error(`Encryption error. Reason: ${encryptionResult.error}`);
  }
  return [u8aToHex(encryptionResult.result), userEncryptionKey];
}
async function decryptNodeResponse(nodeURL, encryptedResponse, encryptionKey) {
  const encryptionPrivateKey = deriveEncryptionKey(encryptionKey, stringToU8a(USER_KEY_PREFIX));
  const nodePublicKeyResponse = await getNodePublicKey(nodeURL);
  if (!nodePublicKeyResponse.publicKey) {
    throw new Error(`Cannot obtain node public key. Reason: ${nodePublicKeyResponse.error}`);
  }
  const nodePublicKey = nodePublicKeyResponse.publicKey;
  const decryptionResult = decryptECDH(encryptionPrivateKey, hexToU8a(nodePublicKey), hexToU8a(encryptedResponse));
  if (!decryptionResult.result) {
    throw new Error(`Decryption error. Reason: ${decryptionResult.error}`);
  }
  return decryptionResult.result;
}
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
dist.utils = dist.decode = dist.encode = void 0;
function encode2(input) {
  if (Array.isArray(input)) {
    const output2 = [];
    for (let i = 0; i < input.length; i++) {
      output2.push(encode2(input[i]));
    }
    const buf = concatBytes(...output2);
    return concatBytes(encodeLength(buf.length, 192), buf);
  }
  const inputBuf = toBytes(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128) {
    return inputBuf;
  }
  return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
dist.encode = encode2;
function safeSlice(input, start, end) {
  if (end > input.length) {
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  }
  return input.slice(start, end);
}
function decodeLength(v2) {
  if (v2[0] === 0) {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseHexByte(bytesToHex(v2));
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Uint8Array.from([len + offset]);
  }
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (!input || input.length === 0) {
    return Uint8Array.from([]);
  }
  const inputBytes = toBytes(input);
  const decoded = _decode(inputBytes);
  if (stream) {
    return decoded;
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid RLP: remainder must be zero");
  }
  return decoded.data;
}
dist.decode = decode;
function _decode(input) {
  let length, llength, data, innerRemainder, d2;
  const decoded = [];
  const firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = Uint8Array.from([]);
    } else {
      data = safeSlice(input, 1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    }
    return {
      data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = decodeLength(safeSlice(input, 1, llength));
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = safeSlice(input, llength, length + llength);
    return {
      data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = safeSlice(input, 1, length);
    while (innerRemainder.length) {
      d2 = _decode(innerRemainder);
      decoded.push(d2.data);
      innerRemainder = d2.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    llength = firstByte - 246;
    length = decodeLength(safeSlice(input, 1, llength));
    if (length < 56) {
      throw new Error("invalid RLP: encoded list too short");
    }
    const totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid RLP: total length is larger than the data");
    }
    innerRemainder = safeSlice(input, llength, totalLength);
    while (innerRemainder.length) {
      d2 = _decode(innerRemainder);
      decoded.push(d2.data);
      innerRemainder = d2.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  let hex2 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex2 += cachedHexes[uint8a[i]];
  }
  return hex2;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
  }
  if (hex2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex2.slice(j, j + 2));
  }
  return array;
}
function concatBytes(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad2);
    pad2 += arr.length;
  }
  return result;
}
function utf8ToBytes(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex2 = integer.toString(16);
  return hex2.length % 2 ? `0${hex2}` : hex2;
}
function padToEven(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function toBytes(v2) {
  if (v2 instanceof Uint8Array) {
    return v2;
  }
  if (typeof v2 === "string") {
    if (isHexPrefixed(v2)) {
      return hexToBytes(padToEven(stripHexPrefix(v2)));
    }
    return utf8ToBytes(v2);
  }
  if (typeof v2 === "number" || typeof v2 === "bigint") {
    if (!v2) {
      return Uint8Array.from([]);
    }
    return hexToBytes(numberToHex(v2));
  }
  if (v2 === null || v2 === void 0) {
    return Uint8Array.from([]);
  }
  throw new Error("toBytes: received unsupported type " + typeof v2);
}
dist.utils = {
  bytesToHex,
  concatBytes,
  hexToBytes,
  utf8ToBytes
};
const RLP = { encode: encode2, decode };
var _default = dist.default = RLP;
function encodeVerifiableCredentialToRLP(credential) {
  if (credential.proof["type"] !== "JwtProof2020") {
    throw new Error(`encodeVerifiableCredentialToRLP: unsupported proof type: ${credential.proof["type"]}`);
  }
  const proof = credential.proof["jwt"];
  return u8aToHex(_default.encode(proof));
}
function encodeTxDataWithVC(credential) {
  const functionSignature = "function authorize(bytes proof)";
  const contractInterface = new Interface([functionSignature]);
  const encodedCredential = encodeVerifiableCredentialToRLP(credential);
  return contractInterface.encodeFunctionData("authorize", [encodedCredential]);
}
const abi = [
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "credential",
        "type": "bytes"
      }
    ],
    "name": "authorize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "authorizedUsers",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "output",
        "type": "bytes"
      }
    ],
    "name": "decodeResult",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "isAuthorized",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
];
const DEMO_CONTRACT_ADDRESS = "0x2932Bd8a5e4b96E482344ceff065aFA34338aB97";
const DEMO_RPC_ENDPOINT = "https://json-rpc.testnet.swisstronik.com";
const getSigner = async () => {
  const { ethereum } = window;
  const provider = new Web3Provider(ethereum);
  try {
    const res = await provider.send("eth_requestAccounts", []);
    if (res.length == 0) {
      return null;
    }
    return [res[0], provider.getSigner()];
  } catch {
    return null;
  }
};
const sendShieldedQuery = async (provider, destination, data) => {
  const [encryptedData, usedEncryptedKey] = await encryptDataField(provider.connection.url, data);
  const response = await provider.call({
    to: destination,
    data: encryptedData
  });
  return await decryptNodeResponse(provider.connection.url, response, usedEncryptedKey);
};
const sendShieldedTransaction = async (provider, signer, destination, data) => {
  const [encryptedData] = await encryptDataField(provider.connection.url, data);
  return await signer.sendTransaction({
    from: await signer.getAddress(),
    to: destination,
    data: encryptedData,
    gasPrice: 7,
    gasLimit: 2e5
  });
};
const requestVerifiedUsersCount = async (provider, destination) => {
  const contract = new Contract(destination, abi);
  const queryData = contract.interface.encodeFunctionData("authorizedUsers", []);
  const res = await sendShieldedQuery(provider, destination, queryData);
  return contract.interface.decodeFunctionResult("authorizedUsers", res)[0].toNumber();
};
const requestIfUserIsVerified = async (provider, destination, userAddress) => {
  const contract = new Contract(destination, abi);
  const queryData = contract.interface.encodeFunctionData("isAuthorized", [userAddress]);
  const res = await sendShieldedQuery(provider, destination, queryData);
  return contract.interface.decodeFunctionResult("isAuthorized", res)[0];
};
const authorizeVerifiableCredential = async (provider, signer, destination, credential) => {
  const txData = encodeTxDataWithVC(credential);
  const authTx = await sendShieldedTransaction(provider, signer, destination, txData);
  console.log(authTx);
  const receipt = await authTx.wait();
  console.log(receipt);
  return receipt;
};
const MyContext = reactExports.createContext({
  userAddress: null,
  setUserAddress: () => void 0,
  did: null,
  setDid: () => void 0,
  signer: null,
  setSigner: () => void 0
});
axios$1.defaults.timeout = 6e4;
function handleAxiosSuccess(response, returnOnlyData) {
  if (response.status >= 200 && response.status < 300) {
    return !returnOnlyData ? response.data : response.data.result;
  } else {
    throw new Error(`Unexpected status code: ${response.status}, errors: ${response.data.errors}`);
  }
}
function handleAxiosError(error) {
  if (axios$1.isAxiosError(error)) {
    return error;
  } else {
    console.error("reject request", error);
    return;
  }
}
async function postRequest(url, params, config) {
  return await axios$1.post(url, params, config);
}
const issuerApi = "https://issuer.sdi.swisstronik.com";
const createDid = async (requestData, config) => {
  const url = `${issuerApi}/api/did/create`;
  try {
    const response = await postRequest(url, requestData, config);
    return handleAxiosSuccess(response, true);
  } catch (error) {
    return handleAxiosError(error);
  }
};
function renderError(message) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex min-h-screen flex-col items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-col items-center justify-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(InfoBlock, { warnMessage: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed bottom-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MontainsShaped, {}) })
  ] }) });
}
function renderLoading() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex min-h-screen flex-col items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-col items-center justify-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-bounce", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RaysPreloader, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: BaseStyles.webMainHeadingMobile, children: "Loading" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed bottom-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MontainsShaped, {}) })
  ] }) });
}
function renderButton(btn) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex min-h-screen flex-col items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "connect__container --login mx-6 rounded-3xl border border-kyc-secondary p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DappHeader,
      {
        classes: "mb-6",
        providerInfo: "",
        smallHeading: true,
        headerTitle: "SDI Example Service is asking to verify your identity"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: btn })
  ] }) }) }) });
}
const ConnectService = () => {
  const [isConnected, setConnected] = reactExports.useState(null);
  const { userAddress, setUserAddress, setSigner, setDid } = reactExports.useContext(MyContext);
  const [loading, setLoading] = reactExports.useState(false);
  const [didError, setDidError] = reactExports.useState("");
  const navigate = useNavigate();
  const connectMetamask = async () => {
    setLoading(true);
    const signerRes = await getSigner();
    console.log(signerRes);
    setLoading(false);
    if (signerRes === null) {
      setConnected(false);
    } else {
      const [userAddress2, signer] = signerRes;
      if (signer) {
        setSigner(signer);
        setUserAddress(userAddress2);
        setConnected(true);
      } else {
        setConnected(false);
      }
    }
  };
  const issueActualDID = async () => {
    setLoading(true);
    setDidError("");
    const didRes = await createDid({ user_address: userAddress }, {});
    setLoading(false);
    if (axios$1.isAxiosError(didRes)) {
      setDidError(didRes.message);
    } else if (didRes === void 0) {
      setDidError("Unknown error occured");
    } else {
      setDid(didRes);
      navigate("/auth-result");
    }
  };
  if (!window["ethereum"]) {
    return renderError("Metamask not found");
  }
  if (loading) {
    return renderLoading();
  }
  if (didError) {
    return renderError(didError);
  }
  if (isConnected !== null) {
    if (isConnected) {
      return renderButton(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `${BaseStyles.actionBtnAccent} 
                self-center border border-kyc-primary-dark px-4 py-3 !text-sm uppercase`,
            onClick: issueActualDID,
            children: "Issue DID"
          }
        )
      );
    } else {
      return renderError("Connection error");
    }
  }
  return renderButton(
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: `${BaseStyles.actionBtnAccent} 
                self-center border border-kyc-primary-dark px-4 py-3 !text-sm uppercase`,
        onClick: connectMetamask,
        children: "Connect Metamask to use SDI"
      }
    )
  );
};
const ConnectAuthResultPage = () => {
  const navigate = useNavigate();
  const { userAddress, signer, did } = reactExports.useContext(MyContext);
  const [verificationResult, setVerificationResult] = reactExports.useState({
    count: 0,
    isVerified: false
  });
  const [loading, setLoading] = reactExports.useState(false);
  const fetchAuthState = async (address) => {
    try {
      setLoading(true);
      const provider = new JsonRpcProvider(DEMO_RPC_ENDPOINT);
      const counter = await requestVerifiedUsersCount(provider, DEMO_CONTRACT_ADDRESS);
      const isVerified = await requestIfUserIsVerified(provider, DEMO_CONTRACT_ADDRESS, address);
      setVerificationResult({ count: counter, isVerified });
      setLoading(false);
    } catch (e2) {
      setLoading(false);
      console.error("Cannot obtain data. Reason: ", e2);
    }
  };
  reactExports.useEffect(() => {
    if (userAddress) {
      fetchAuthState(userAddress);
    } else {
      if (userAddress === null || signer === null || did === null) {
        console.log(
          `Navigating to root because - userAddress is null: ${userAddress === null}, signer is null: ${signer === null}, did is null: ${did === null}`
        );
        navigate("/");
      }
    }
  }, []);
  const authorizeDID = async () => {
    setLoading(true);
    const provider = new JsonRpcProvider(DEMO_RPC_ENDPOINT);
    const res = await authorizeVerifiableCredential(
      provider,
      signer,
      DEMO_CONTRACT_ADDRESS,
      did
    );
    console.log(res);
    setLoading(false);
    await fetchAuthState(userAddress);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex min-h-screen flex-col items-center justify-center", children: [
    !loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "mb-6 flex flex-col items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2 flex h-11 w-11 items-center justify-center rounded-full border-2 border-kyc-primary-dark", children: verificationResult && verificationResult.isVerified ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { name: "checkmark", color: "", size: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icons, { name: "cross", color: "", size: "24" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: verificationResult && verificationResult.isVerified ? "Verification passed" : "Not verified" }),
        !verificationResult || !verificationResult.isVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `${BaseStyles.actionBtnAccent} 
                  mt-4 self-center border border-kyc-primary-dark px-4 py-3 !text-sm uppercase`,
            onClick: authorizeDID,
            children: "Verify DID"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ResultTable, { userAddress, authResult: verificationResult })
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-bounce", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RaysPreloader, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: BaseStyles.webMainHeadingMobile, children: "Loading" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed bottom-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MontainsShaped, {}) })
  ] });
};
const ResultTable = ({
  userAddress,
  authResult
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connect__container --login mx-6 rounded-3xl border border-kyc-secondary p-12", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex flex-wrap items-center justify-between border-b border-kyc-secondary pb-2.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[50%]", children: "Address" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[100px] truncate", children: userAddress })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex flex-wrap items-center justify-between border-b border-kyc-secondary pb-2.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[80%]", children: "Verified users count " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: authResult.count })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex flex-wrap items-center justify-between border-b border-kyc-secondary pb-2.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[80%]", children: "Is verified" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: authResult.isVerified ? "True" : "False" })
    ] })
  ] });
};
const MyProvider = ({ children }) => {
  const [did, setDid] = reactExports.useState(null);
  const [userAddress, setUserAddress] = reactExports.useState(null);
  const [signer, setSigner] = reactExports.useState(null);
  const provideObject = {
    did,
    setDid,
    userAddress,
    setUserAddress,
    signer,
    setSigner
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MyContext.Provider, { value: provideObject, children });
};
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MyProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectService, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/auth-result", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectAuthResultPage, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NotFoundPage, {}) })
  ] }) }) }) })
);
